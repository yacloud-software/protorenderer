// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/protorenderer/protorenderer.proto
// DO NOT EDIT!

/*
Package protorenderer is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/protorenderer/protorenderer.proto

It has these top-level messages:
	DBProtoFile
	PersistID
	AddProtoRequest
	AddProtoResponse
	ProtoFile
	MetaProtoFile
	Package
	PackageFindResult
	Service
	RPC
	Message
	Field
	PackageIDRequest
	ID
	MessageIDRequest
	FilenameList
	FileRequest
	File
	Version
	ProtocRequest
	FlatPackage
	FlatPackageList
	CompileRequest
	CompileResult
	CompiledFile
	DeleteRequest
	FindServiceByNameRequest
	ServiceList
	ServiceResponse
	PackageName
	FileStream
*/
package protorenderer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"
import google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CompilerType int32

const (
	CompilerType_UNDEFINED CompilerType = 0
	CompilerType_GOLANG    CompilerType = 1
	CompilerType_JAVA      CompilerType = 2
	CompilerType_PYTHON    CompilerType = 3
	CompilerType_NANOPB    CompilerType = 4
	CompilerType_CPLUSPLUS CompilerType = 5
)

var CompilerType_name = map[int32]string{
	0: "UNDEFINED",
	1: "GOLANG",
	2: "JAVA",
	3: "PYTHON",
	4: "NANOPB",
	5: "CPLUSPLUS",
}
var CompilerType_value = map[string]int32{
	"UNDEFINED": 0,
	"GOLANG":    1,
	"JAVA":      2,
	"PYTHON":    3,
	"NANOPB":    4,
	"CPLUSPLUS": 5,
}

func (x CompilerType) String() string {
	return proto.EnumName(CompilerType_name, int32(x))
}
func (CompilerType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// keeping a file in database with metadata
type DBProtoFile struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	RepositoryID uint64 `protobuf:"varint,3,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
}

func (m *DBProtoFile) Reset()                    { *m = DBProtoFile{} }
func (m *DBProtoFile) String() string            { return proto.CompactTextString(m) }
func (*DBProtoFile) ProtoMessage()               {}
func (*DBProtoFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DBProtoFile) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBProtoFile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DBProtoFile) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

// simple database mapping strategy to keep persistent IDs between restarts
type PersistID struct {
	ID  uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Key string `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
}

func (m *PersistID) Reset()                    { *m = PersistID{} }
func (m *PersistID) String() string            { return proto.CompactTextString(m) }
func (*PersistID) ProtoMessage()               {}
func (*PersistID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PersistID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PersistID) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// add a single proto to the proto repo
type AddProtoRequest struct {
	Name         string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Content      string `protobuf:"bytes,2,opt,name=Content" json:"Content,omitempty"`
	RepositoryID uint64 `protobuf:"varint,3,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
}

func (m *AddProtoRequest) Reset()                    { *m = AddProtoRequest{} }
func (m *AddProtoRequest) String() string            { return proto.CompactTextString(m) }
func (*AddProtoRequest) ProtoMessage()               {}
func (*AddProtoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AddProtoRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AddProtoRequest) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *AddProtoRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

// response to adding a single proto
type AddProtoResponse struct {
	Version      uint64   `protobuf:"varint,1,opt,name=Version" json:"Version,omitempty"`
	ProtoVersion uint64   `protobuf:"varint,2,opt,name=ProtoVersion" json:"ProtoVersion,omitempty"`
	GoPackage    string   `protobuf:"bytes,3,opt,name=GoPackage" json:"GoPackage,omitempty"`
	JavaPackage  string   `protobuf:"bytes,4,opt,name=JavaPackage" json:"JavaPackage,omitempty"`
	Imports      []string `protobuf:"bytes,5,rep,name=Imports" json:"Imports,omitempty"`
}

func (m *AddProtoResponse) Reset()                    { *m = AddProtoResponse{} }
func (m *AddProtoResponse) String() string            { return proto.CompactTextString(m) }
func (*AddProtoResponse) ProtoMessage()               {}
func (*AddProtoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AddProtoResponse) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *AddProtoResponse) GetProtoVersion() uint64 {
	if m != nil {
		return m.ProtoVersion
	}
	return 0
}

func (m *AddProtoResponse) GetGoPackage() string {
	if m != nil {
		return m.GoPackage
	}
	return ""
}

func (m *AddProtoResponse) GetJavaPackage() string {
	if m != nil {
		return m.JavaPackage
	}
	return ""
}

func (m *AddProtoResponse) GetImports() []string {
	if m != nil {
		return m.Imports
	}
	return nil
}

type ProtoFile struct {
	GoPackage   string   `protobuf:"bytes,1,opt,name=GoPackage" json:"GoPackage,omitempty"`
	JavaPackage string   `protobuf:"bytes,2,opt,name=JavaPackage" json:"JavaPackage,omitempty"`
	Filename    string   `protobuf:"bytes,3,opt,name=Filename" json:"Filename,omitempty"`
	Content     string   `protobuf:"bytes,4,opt,name=Content" json:"Content,omitempty"`
	Imports     []string `protobuf:"bytes,5,rep,name=Imports" json:"Imports,omitempty"`
	//
	// metacompiler adds ingredients here at the end of its compile process.
	// this provides a backreference to the 'meta-compiled' details for each protofile
	Meta         *MetaProtoFile `protobuf:"bytes,6,opt,name=Meta" json:"Meta,omitempty"`
	RepositoryID uint64         `protobuf:"varint,7,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
}

func (m *ProtoFile) Reset()                    { *m = ProtoFile{} }
func (m *ProtoFile) String() string            { return proto.CompactTextString(m) }
func (*ProtoFile) ProtoMessage()               {}
func (*ProtoFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ProtoFile) GetGoPackage() string {
	if m != nil {
		return m.GoPackage
	}
	return ""
}

func (m *ProtoFile) GetJavaPackage() string {
	if m != nil {
		return m.JavaPackage
	}
	return ""
}

func (m *ProtoFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *ProtoFile) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *ProtoFile) GetImports() []string {
	if m != nil {
		return m.Imports
	}
	return nil
}

func (m *ProtoFile) GetMeta() *MetaProtoFile {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ProtoFile) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

// link between "meta" and our protofiles.
type MetaProtoFile struct {
	// the package this protofile is in
	PackageID string `protobuf:"bytes,1,opt,name=PackageID" json:"PackageID,omitempty"`
	// the "package" meta has parsed
	Package *Package `protobuf:"bytes,2,opt,name=Package" json:"Package,omitempty"`
}

func (m *MetaProtoFile) Reset()                    { *m = MetaProtoFile{} }
func (m *MetaProtoFile) String() string            { return proto.CompactTextString(m) }
func (*MetaProtoFile) ProtoMessage()               {}
func (*MetaProtoFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *MetaProtoFile) GetPackageID() string {
	if m != nil {
		return m.PackageID
	}
	return ""
}

func (m *MetaProtoFile) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

// package has an ID which we attempt to keep stable
// suitable for semi-shortterm references, e.g. html links
type Package struct {
	ID       string     `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name     string     `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Prefix   string     `protobuf:"bytes,3,opt,name=Prefix" json:"Prefix,omitempty"`
	Services []*Service `protobuf:"bytes,4,rep,name=Services" json:"Services,omitempty"`
	Messages []*Message `protobuf:"bytes,5,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *Package) Reset()                    { *m = Package{} }
func (m *Package) String() string            { return proto.CompactTextString(m) }
func (*Package) ProtoMessage()               {}
func (*Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Package) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Package) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Package) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *Package) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type PackageFindResult struct {
	Exists  bool     `protobuf:"varint,1,opt,name=Exists" json:"Exists,omitempty"`
	Package *Package `protobuf:"bytes,2,opt,name=Package" json:"Package,omitempty"`
}

func (m *PackageFindResult) Reset()                    { *m = PackageFindResult{} }
func (m *PackageFindResult) String() string            { return proto.CompactTextString(m) }
func (*PackageFindResult) ProtoMessage()               {}
func (*PackageFindResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PackageFindResult) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *PackageFindResult) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

type Service struct {
	ID           string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	RPCs         []*RPC `protobuf:"bytes,3,rep,name=RPCs" json:"RPCs,omitempty"`
	Comment      string `protobuf:"bytes,4,opt,name=Comment" json:"Comment,omitempty"`
	PackageID    string `protobuf:"bytes,5,opt,name=PackageID" json:"PackageID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,6,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Service) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetRPCs() []*RPC {
	if m != nil {
		return m.RPCs
	}
	return nil
}

func (m *Service) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Service) GetPackageID() string {
	if m != nil {
		return m.PackageID
	}
	return ""
}

func (m *Service) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

type RPC struct {
	ID         string   `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name       string   `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Input      *Message `protobuf:"bytes,3,opt,name=Input" json:"Input,omitempty"`
	Output     *Message `protobuf:"bytes,4,opt,name=Output" json:"Output,omitempty"`
	Comment    string   `protobuf:"bytes,5,opt,name=Comment" json:"Comment,omitempty"`
	ServiceID  string   `protobuf:"bytes,6,opt,name=ServiceID" json:"ServiceID,omitempty"`
	Deprecated bool     `protobuf:"varint,7,opt,name=Deprecated" json:"Deprecated,omitempty"`
}

func (m *RPC) Reset()                    { *m = RPC{} }
func (m *RPC) String() string            { return proto.CompactTextString(m) }
func (*RPC) ProtoMessage()               {}
func (*RPC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RPC) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *RPC) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RPC) GetInput() *Message {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *RPC) GetOutput() *Message {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *RPC) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *RPC) GetServiceID() string {
	if m != nil {
		return m.ServiceID
	}
	return ""
}

func (m *RPC) GetDeprecated() bool {
	if m != nil {
		return m.Deprecated
	}
	return false
}

type Message struct {
	ID        string   `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name      string   `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Comment   string   `protobuf:"bytes,3,opt,name=Comment" json:"Comment,omitempty"`
	PackageID string   `protobuf:"bytes,4,opt,name=PackageID" json:"PackageID,omitempty"`
	Fields    []*Field `protobuf:"bytes,5,rep,name=Fields" json:"Fields,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Message) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Message) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Message) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Message) GetPackageID() string {
	if m != nil {
		return m.PackageID
	}
	return ""
}

func (m *Message) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	ID          string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Type        string `protobuf:"bytes,3,opt,name=Type" json:"Type,omitempty"`
	ExtraType   string `protobuf:"bytes,4,opt,name=ExtraType" json:"ExtraType,omitempty"`
	Repeated    bool   `protobuf:"varint,5,opt,name=Repeated" json:"Repeated,omitempty"`
	Required    bool   `protobuf:"varint,6,opt,name=Required" json:"Required,omitempty"`
	Optional    bool   `protobuf:"varint,7,opt,name=Optional" json:"Optional,omitempty"`
	Comment     string `protobuf:"bytes,8,opt,name=Comment" json:"Comment,omitempty"`
	MessageID   string `protobuf:"bytes,9,opt,name=MessageID" json:"MessageID,omitempty"`
	MessageName string `protobuf:"bytes,10,opt,name=MessageName" json:"MessageName,omitempty"`
}

func (m *Field) Reset()                    { *m = Field{} }
func (m *Field) String() string            { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()               {}
func (*Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Field) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Field) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Field) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Field) GetExtraType() string {
	if m != nil {
		return m.ExtraType
	}
	return ""
}

func (m *Field) GetRepeated() bool {
	if m != nil {
		return m.Repeated
	}
	return false
}

func (m *Field) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *Field) GetOptional() bool {
	if m != nil {
		return m.Optional
	}
	return false
}

func (m *Field) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Field) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *Field) GetMessageName() string {
	if m != nil {
		return m.MessageName
	}
	return ""
}

type PackageIDRequest struct {
	Package string `protobuf:"bytes,1,opt,name=Package" json:"Package,omitempty"`
	Prefix  string `protobuf:"bytes,2,opt,name=Prefix" json:"Prefix,omitempty"`
}

func (m *PackageIDRequest) Reset()                    { *m = PackageIDRequest{} }
func (m *PackageIDRequest) String() string            { return proto.CompactTextString(m) }
func (*PackageIDRequest) ProtoMessage()               {}
func (*PackageIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PackageIDRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *PackageIDRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

type ID struct {
	// the actual ID
	ID string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ID) Reset()                    { *m = ID{} }
func (m *ID) String() string            { return proto.CompactTextString(m) }
func (*ID) ProtoMessage()               {}
func (*ID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ID) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type MessageIDRequest struct {
	PackageID   string `protobuf:"bytes,1,opt,name=PackageID" json:"PackageID,omitempty"`
	MessageName string `protobuf:"bytes,2,opt,name=MessageName" json:"MessageName,omitempty"`
}

func (m *MessageIDRequest) Reset()                    { *m = MessageIDRequest{} }
func (m *MessageIDRequest) String() string            { return proto.CompactTextString(m) }
func (*MessageIDRequest) ProtoMessage()               {}
func (*MessageIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MessageIDRequest) GetPackageID() string {
	if m != nil {
		return m.PackageID
	}
	return ""
}

func (m *MessageIDRequest) GetMessageName() string {
	if m != nil {
		return m.MessageName
	}
	return ""
}

// ****************************************************************
// Stuff for retrieving files
// ***************************************************************
type FilenameList struct {
	Files []string `protobuf:"bytes,1,rep,name=Files" json:"Files,omitempty"`
}

func (m *FilenameList) Reset()                    { *m = FilenameList{} }
func (m *FilenameList) String() string            { return proto.CompactTextString(m) }
func (*FilenameList) ProtoMessage()               {}
func (*FilenameList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *FilenameList) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

type FileRequest struct {
	PackageID *ID          `protobuf:"bytes,1,opt,name=PackageID" json:"PackageID,omitempty"`
	Filename  string       `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
	Compiler  CompilerType `protobuf:"varint,3,opt,name=Compiler,enum=protorenderer.CompilerType" json:"Compiler,omitempty"`
}

func (m *FileRequest) Reset()                    { *m = FileRequest{} }
func (m *FileRequest) String() string            { return proto.CompactTextString(m) }
func (*FileRequest) ProtoMessage()               {}
func (*FileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *FileRequest) GetPackageID() *ID {
	if m != nil {
		return m.PackageID
	}
	return nil
}

func (m *FileRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FileRequest) GetCompiler() CompilerType {
	if m != nil {
		return m.Compiler
	}
	return CompilerType_UNDEFINED
}

type File struct {
	Content      []byte `protobuf:"bytes,1,opt,name=Content,proto3" json:"Content,omitempty"`
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *File) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *File) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

type Version struct {
	Version      uint64 `protobuf:"varint,1,opt,name=Version" json:"Version,omitempty"`
	Compiling    bool   `protobuf:"varint,2,opt,name=Compiling" json:"Compiling,omitempty"`
	NextVersion  uint64 `protobuf:"varint,3,opt,name=NextVersion" json:"NextVersion,omitempty"`
	ProtoVersion uint64 `protobuf:"varint,4,opt,name=ProtoVersion" json:"ProtoVersion,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Version) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Version) GetCompiling() bool {
	if m != nil {
		return m.Compiling
	}
	return false
}

func (m *Version) GetNextVersion() uint64 {
	if m != nil {
		return m.NextVersion
	}
	return 0
}

func (m *Version) GetProtoVersion() uint64 {
	if m != nil {
		return m.ProtoVersion
	}
	return 0
}

type ProtocRequest struct {
	VerifyToken string                                 `protobuf:"bytes,1,opt,name=VerifyToken" json:"VerifyToken,omitempty"`
	ProtoFiles  []*google_protobuf.FileDescriptorProto `protobuf:"bytes,2,rep,name=ProtoFiles" json:"ProtoFiles,omitempty"`
}

func (m *ProtocRequest) Reset()                    { *m = ProtocRequest{} }
func (m *ProtocRequest) String() string            { return proto.CompactTextString(m) }
func (*ProtocRequest) ProtoMessage()               {}
func (*ProtocRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ProtocRequest) GetVerifyToken() string {
	if m != nil {
		return m.VerifyToken
	}
	return ""
}

func (m *ProtocRequest) GetProtoFiles() []*google_protobuf.FileDescriptorProto {
	if m != nil {
		return m.ProtoFiles
	}
	return nil
}

// a package, but without nested objects
type FlatPackage struct {
	ID           string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Prefix       string `protobuf:"bytes,3,opt,name=Prefix" json:"Prefix,omitempty"`
	RepositoryID uint64 `protobuf:"varint,4,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Filename     string `protobuf:"bytes,5,opt,name=Filename" json:"Filename,omitempty"`
}

func (m *FlatPackage) Reset()                    { *m = FlatPackage{} }
func (m *FlatPackage) String() string            { return proto.CompactTextString(m) }
func (*FlatPackage) ProtoMessage()               {}
func (*FlatPackage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *FlatPackage) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *FlatPackage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FlatPackage) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *FlatPackage) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *FlatPackage) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

type FlatPackageList struct {
	Packages []*FlatPackage `protobuf:"bytes,1,rep,name=Packages" json:"Packages,omitempty"`
}

func (m *FlatPackageList) Reset()                    { *m = FlatPackageList{} }
func (m *FlatPackageList) String() string            { return proto.CompactTextString(m) }
func (*FlatPackageList) ProtoMessage()               {}
func (*FlatPackageList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *FlatPackageList) GetPackages() []*FlatPackage {
	if m != nil {
		return m.Packages
	}
	return nil
}

type CompileRequest struct {
	AddProtoRequest *AddProtoRequest `protobuf:"bytes,1,opt,name=AddProtoRequest" json:"AddProtoRequest,omitempty"`
	Compilers       []CompilerType   `protobuf:"varint,2,rep,packed,name=Compilers,enum=protorenderer.CompilerType" json:"Compilers,omitempty"`
}

func (m *CompileRequest) Reset()                    { *m = CompileRequest{} }
func (m *CompileRequest) String() string            { return proto.CompactTextString(m) }
func (*CompileRequest) ProtoMessage()               {}
func (*CompileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *CompileRequest) GetAddProtoRequest() *AddProtoRequest {
	if m != nil {
		return m.AddProtoRequest
	}
	return nil
}

func (m *CompileRequest) GetCompilers() []CompilerType {
	if m != nil {
		return m.Compilers
	}
	return nil
}

type CompileResult struct {
	SourceFilename string          `protobuf:"bytes,1,opt,name=SourceFilename" json:"SourceFilename,omitempty"`
	CompileError   string          `protobuf:"bytes,2,opt,name=CompileError" json:"CompileError,omitempty"`
	Files          []*CompiledFile `protobuf:"bytes,3,rep,name=Files" json:"Files,omitempty"`
}

func (m *CompileResult) Reset()                    { *m = CompileResult{} }
func (m *CompileResult) String() string            { return proto.CompactTextString(m) }
func (*CompileResult) ProtoMessage()               {}
func (*CompileResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *CompileResult) GetSourceFilename() string {
	if m != nil {
		return m.SourceFilename
	}
	return ""
}

func (m *CompileResult) GetCompileError() string {
	if m != nil {
		return m.CompileError
	}
	return ""
}

func (m *CompileResult) GetFiles() []*CompiledFile {
	if m != nil {
		return m.Files
	}
	return nil
}

type CompiledFile struct {
	Language common.ProgrammingLanguage `protobuf:"varint,1,opt,name=Language,enum=common.ProgrammingLanguage" json:"Language,omitempty"`
	Filename string                     `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
	Content  []byte                     `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
	Compiler CompilerType               `protobuf:"varint,4,opt,name=Compiler,enum=protorenderer.CompilerType" json:"Compiler,omitempty"`
}

func (m *CompiledFile) Reset()                    { *m = CompiledFile{} }
func (m *CompiledFile) String() string            { return proto.CompactTextString(m) }
func (*CompiledFile) ProtoMessage()               {}
func (*CompiledFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *CompiledFile) GetLanguage() common.ProgrammingLanguage {
	if m != nil {
		return m.Language
	}
	return common.ProgrammingLanguage_INVALID
}

func (m *CompiledFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *CompiledFile) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *CompiledFile) GetCompiler() CompilerType {
	if m != nil {
		return m.Compiler
	}
	return CompilerType_UNDEFINED
}

type DeleteRequest struct {
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *DeleteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type FindServiceByNameRequest struct {
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
}

func (m *FindServiceByNameRequest) Reset()                    { *m = FindServiceByNameRequest{} }
func (m *FindServiceByNameRequest) String() string            { return proto.CompactTextString(m) }
func (*FindServiceByNameRequest) ProtoMessage()               {}
func (*FindServiceByNameRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *FindServiceByNameRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ServiceList struct {
	Services []*ServiceResponse `protobuf:"bytes,1,rep,name=Services" json:"Services,omitempty"`
}

func (m *ServiceList) Reset()                    { *m = ServiceList{} }
func (m *ServiceList) String() string            { return proto.CompactTextString(m) }
func (*ServiceList) ProtoMessage()               {}
func (*ServiceList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *ServiceList) GetServices() []*ServiceResponse {
	if m != nil {
		return m.Services
	}
	return nil
}

type ServiceResponse struct {
	Service     *Service `protobuf:"bytes,1,opt,name=Service" json:"Service,omitempty"`
	Package     *Package `protobuf:"bytes,2,opt,name=Package" json:"Package,omitempty"`
	PackageName string   `protobuf:"bytes,3,opt,name=PackageName" json:"PackageName,omitempty"`
	PackageFQDN string   `protobuf:"bytes,4,opt,name=PackageFQDN" json:"PackageFQDN,omitempty"`
}

func (m *ServiceResponse) Reset()                    { *m = ServiceResponse{} }
func (m *ServiceResponse) String() string            { return proto.CompactTextString(m) }
func (*ServiceResponse) ProtoMessage()               {}
func (*ServiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ServiceResponse) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *ServiceResponse) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

func (m *ServiceResponse) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *ServiceResponse) GetPackageFQDN() string {
	if m != nil {
		return m.PackageFQDN
	}
	return ""
}

type PackageName struct {
	PackageName string `protobuf:"bytes,1,opt,name=PackageName" json:"PackageName,omitempty"`
}

func (m *PackageName) Reset()                    { *m = PackageName{} }
func (m *PackageName) String() string            { return proto.CompactTextString(m) }
func (*PackageName) ProtoMessage()               {}
func (*PackageName) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *PackageName) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

// guaranteed to send the payload in order, and one file after the other,
// that, the server will never interleave payload of different filenames.
// if filename changes during the stream, the previous file is complete.
type FileStream struct {
	Filename string `protobuf:"bytes,1,opt,name=Filename" json:"Filename,omitempty"`
	Payload  []byte `protobuf:"bytes,2,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *FileStream) Reset()                    { *m = FileStream{} }
func (m *FileStream) String() string            { return proto.CompactTextString(m) }
func (*FileStream) ProtoMessage()               {}
func (*FileStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *FileStream) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FileStream) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterType((*DBProtoFile)(nil), "protorenderer.DBProtoFile")
	proto.RegisterType((*PersistID)(nil), "protorenderer.PersistID")
	proto.RegisterType((*AddProtoRequest)(nil), "protorenderer.AddProtoRequest")
	proto.RegisterType((*AddProtoResponse)(nil), "protorenderer.AddProtoResponse")
	proto.RegisterType((*ProtoFile)(nil), "protorenderer.ProtoFile")
	proto.RegisterType((*MetaProtoFile)(nil), "protorenderer.MetaProtoFile")
	proto.RegisterType((*Package)(nil), "protorenderer.Package")
	proto.RegisterType((*PackageFindResult)(nil), "protorenderer.PackageFindResult")
	proto.RegisterType((*Service)(nil), "protorenderer.Service")
	proto.RegisterType((*RPC)(nil), "protorenderer.RPC")
	proto.RegisterType((*Message)(nil), "protorenderer.Message")
	proto.RegisterType((*Field)(nil), "protorenderer.Field")
	proto.RegisterType((*PackageIDRequest)(nil), "protorenderer.PackageIDRequest")
	proto.RegisterType((*ID)(nil), "protorenderer.ID")
	proto.RegisterType((*MessageIDRequest)(nil), "protorenderer.MessageIDRequest")
	proto.RegisterType((*FilenameList)(nil), "protorenderer.FilenameList")
	proto.RegisterType((*FileRequest)(nil), "protorenderer.FileRequest")
	proto.RegisterType((*File)(nil), "protorenderer.File")
	proto.RegisterType((*Version)(nil), "protorenderer.Version")
	proto.RegisterType((*ProtocRequest)(nil), "protorenderer.ProtocRequest")
	proto.RegisterType((*FlatPackage)(nil), "protorenderer.FlatPackage")
	proto.RegisterType((*FlatPackageList)(nil), "protorenderer.FlatPackageList")
	proto.RegisterType((*CompileRequest)(nil), "protorenderer.CompileRequest")
	proto.RegisterType((*CompileResult)(nil), "protorenderer.CompileResult")
	proto.RegisterType((*CompiledFile)(nil), "protorenderer.CompiledFile")
	proto.RegisterType((*DeleteRequest)(nil), "protorenderer.DeleteRequest")
	proto.RegisterType((*FindServiceByNameRequest)(nil), "protorenderer.FindServiceByNameRequest")
	proto.RegisterType((*ServiceList)(nil), "protorenderer.ServiceList")
	proto.RegisterType((*ServiceResponse)(nil), "protorenderer.ServiceResponse")
	proto.RegisterType((*PackageName)(nil), "protorenderer.PackageName")
	proto.RegisterType((*FileStream)(nil), "protorenderer.FileStream")
	proto.RegisterEnum("protorenderer.CompilerType", CompilerType_name, CompilerType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ProtoRendererService service

type ProtoRendererServiceClient interface {
	// add or update a ".proto" file in the renderers database
	UpdateProto(ctx context.Context, in *AddProtoRequest, opts ...grpc.CallOption) (*AddProtoResponse, error)
	// basic parse ;). Fast, quick no dependency parser
	MiniParser(ctx context.Context, in *AddProtoRequest, opts ...grpc.CallOption) (*ProtoFile, error)
	// we can submit protofiles from protoc to protorenderer server for analysis
	SubmitSource(ctx context.Context, in *ProtocRequest, opts ...grpc.CallOption) (*common.Void, error)
	// download classes, jars, .pb.go files or a tar full of pythons
	StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (ProtoRendererService_StreamHTTPClient, error)
	// get all packages ("flat", it does not include services/message protos)
	GetPackages(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*FlatPackageList, error)
	// get a specific package (not "flat", it _does_ include services/messages protos)
	GetPackageByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Package, error)
	// get all java class names for a given packageID
	// This is an EXPERIMENTAL API - subject to change.
	// the match between "package" and "namespace" and "filename" is ill-defined. In future
	// The api might return filenames in an abstract naming scheme (or not) and requires
	// more input parameters.
	GetFilesJavaClass(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error)
	// get all .pb.go files for a given package
	GetFilesGO(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error)
	// get all .proto files for a given package
	GetFilesProto(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error)
	// get all .py files for a given package
	GetFilesPython(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error)
	// get all nanopb files for a given package
	GetFilesNanoPB(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error)
	//
	// get a specific file by filename
	// This is an EXPERIMENTAL API - subject to change.
	// the match between "package" and "namespace" and "filename" is ill-defined. In future
	// The api might return filenames in an abstract naming scheme (or not) and requires
	// more input parameters.
	GetFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*File, error)
	// get the current version of the store
	GetVersion(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Version, error)
	// compile a file, return output(s), but do not store results
	CompileFile(ctx context.Context, in *CompileRequest, opts ...grpc.CallOption) (*CompileResult, error)
	// list all sourcefiles
	ListSourceFiles(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*FilenameList, error)
	// delete a file
	DeleteFile(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*common.Void, error)
	// find a service by name (might return multiple - beware)
	FindServiceByName(ctx context.Context, in *FindServiceByNameRequest, opts ...grpc.CallOption) (*ServiceList, error)
	// get a service by ID
	FindServiceByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ServiceResponse, error)
	// get .pb.go files for a given package, stream one file after the other
	GetFilesGoByPackageName(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (ProtoRendererService_GetFilesGoByPackageNameClient, error)
	// get packageid by name
	GetPackageByName(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (*Package, error)
	// get packageid by name (no error)
	FindPackageByName(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (*PackageFindResult, error)
}

type protoRendererServiceClient struct {
	cc *grpc.ClientConn
}

func NewProtoRendererServiceClient(cc *grpc.ClientConn) ProtoRendererServiceClient {
	return &protoRendererServiceClient{cc}
}

func (c *protoRendererServiceClient) UpdateProto(ctx context.Context, in *AddProtoRequest, opts ...grpc.CallOption) (*AddProtoResponse, error) {
	out := new(AddProtoResponse)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/UpdateProto", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) MiniParser(ctx context.Context, in *AddProtoRequest, opts ...grpc.CallOption) (*ProtoFile, error) {
	out := new(ProtoFile)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/MiniParser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) SubmitSource(ctx context.Context, in *ProtocRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/SubmitSource", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (ProtoRendererService_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ProtoRendererService_serviceDesc.Streams[0], c.cc, "/protorenderer.ProtoRendererService/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &protoRendererServiceStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ProtoRendererService_StreamHTTPClient interface {
	Recv() (*h2gproxy.StreamDataResponse, error)
	grpc.ClientStream
}

type protoRendererServiceStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *protoRendererServiceStreamHTTPClient) Recv() (*h2gproxy.StreamDataResponse, error) {
	m := new(h2gproxy.StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *protoRendererServiceClient) GetPackages(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*FlatPackageList, error) {
	out := new(FlatPackageList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetPackages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetPackageByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Package, error) {
	out := new(Package)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetPackageByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetFilesJavaClass(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error) {
	out := new(FilenameList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetFilesJavaClass", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetFilesGO(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error) {
	out := new(FilenameList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetFilesGO", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetFilesProto(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error) {
	out := new(FilenameList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetFilesProto", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetFilesPython(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error) {
	out := new(FilenameList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetFilesPython", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetFilesNanoPB(ctx context.Context, in *ID, opts ...grpc.CallOption) (*FilenameList, error) {
	out := new(FilenameList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetFilesNanoPB", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*File, error) {
	out := new(File)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetVersion(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) CompileFile(ctx context.Context, in *CompileRequest, opts ...grpc.CallOption) (*CompileResult, error) {
	out := new(CompileResult)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/CompileFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) ListSourceFiles(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*FilenameList, error) {
	out := new(FilenameList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/ListSourceFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) DeleteFile(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/DeleteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) FindServiceByName(ctx context.Context, in *FindServiceByNameRequest, opts ...grpc.CallOption) (*ServiceList, error) {
	out := new(ServiceList)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/FindServiceByName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) FindServiceByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ServiceResponse, error) {
	out := new(ServiceResponse)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/FindServiceByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) GetFilesGoByPackageName(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (ProtoRendererService_GetFilesGoByPackageNameClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ProtoRendererService_serviceDesc.Streams[1], c.cc, "/protorenderer.ProtoRendererService/GetFilesGoByPackageName", opts...)
	if err != nil {
		return nil, err
	}
	x := &protoRendererServiceGetFilesGoByPackageNameClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ProtoRendererService_GetFilesGoByPackageNameClient interface {
	Recv() (*FileStream, error)
	grpc.ClientStream
}

type protoRendererServiceGetFilesGoByPackageNameClient struct {
	grpc.ClientStream
}

func (x *protoRendererServiceGetFilesGoByPackageNameClient) Recv() (*FileStream, error) {
	m := new(FileStream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *protoRendererServiceClient) GetPackageByName(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (*Package, error) {
	out := new(Package)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/GetPackageByName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *protoRendererServiceClient) FindPackageByName(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (*PackageFindResult, error) {
	out := new(PackageFindResult)
	err := grpc.Invoke(ctx, "/protorenderer.ProtoRendererService/FindPackageByName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ProtoRendererService service

type ProtoRendererServiceServer interface {
	// add or update a ".proto" file in the renderers database
	UpdateProto(context.Context, *AddProtoRequest) (*AddProtoResponse, error)
	// basic parse ;). Fast, quick no dependency parser
	MiniParser(context.Context, *AddProtoRequest) (*ProtoFile, error)
	// we can submit protofiles from protoc to protorenderer server for analysis
	SubmitSource(context.Context, *ProtocRequest) (*common.Void, error)
	// download classes, jars, .pb.go files or a tar full of pythons
	StreamHTTP(*h2gproxy.StreamRequest, ProtoRendererService_StreamHTTPServer) error
	// get all packages ("flat", it does not include services/message protos)
	GetPackages(context.Context, *common.Void) (*FlatPackageList, error)
	// get a specific package (not "flat", it _does_ include services/messages protos)
	GetPackageByID(context.Context, *ID) (*Package, error)
	// get all java class names for a given packageID
	// This is an EXPERIMENTAL API - subject to change.
	// the match between "package" and "namespace" and "filename" is ill-defined. In future
	// The api might return filenames in an abstract naming scheme (or not) and requires
	// more input parameters.
	GetFilesJavaClass(context.Context, *ID) (*FilenameList, error)
	// get all .pb.go files for a given package
	GetFilesGO(context.Context, *ID) (*FilenameList, error)
	// get all .proto files for a given package
	GetFilesProto(context.Context, *ID) (*FilenameList, error)
	// get all .py files for a given package
	GetFilesPython(context.Context, *ID) (*FilenameList, error)
	// get all nanopb files for a given package
	GetFilesNanoPB(context.Context, *ID) (*FilenameList, error)
	//
	// get a specific file by filename
	// This is an EXPERIMENTAL API - subject to change.
	// the match between "package" and "namespace" and "filename" is ill-defined. In future
	// The api might return filenames in an abstract naming scheme (or not) and requires
	// more input parameters.
	GetFile(context.Context, *FileRequest) (*File, error)
	// get the current version of the store
	GetVersion(context.Context, *common.Void) (*Version, error)
	// compile a file, return output(s), but do not store results
	CompileFile(context.Context, *CompileRequest) (*CompileResult, error)
	// list all sourcefiles
	ListSourceFiles(context.Context, *common.Void) (*FilenameList, error)
	// delete a file
	DeleteFile(context.Context, *DeleteRequest) (*common.Void, error)
	// find a service by name (might return multiple - beware)
	FindServiceByName(context.Context, *FindServiceByNameRequest) (*ServiceList, error)
	// get a service by ID
	FindServiceByID(context.Context, *ID) (*ServiceResponse, error)
	// get .pb.go files for a given package, stream one file after the other
	GetFilesGoByPackageName(*PackageName, ProtoRendererService_GetFilesGoByPackageNameServer) error
	// get packageid by name
	GetPackageByName(context.Context, *PackageName) (*Package, error)
	// get packageid by name (no error)
	FindPackageByName(context.Context, *PackageName) (*PackageFindResult, error)
}

func RegisterProtoRendererServiceServer(s *grpc.Server, srv ProtoRendererServiceServer) {
	s.RegisterService(&_ProtoRendererService_serviceDesc, srv)
}

func _ProtoRendererService_UpdateProto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProtoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).UpdateProto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/UpdateProto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).UpdateProto(ctx, req.(*AddProtoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_MiniParser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProtoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).MiniParser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/MiniParser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).MiniParser(ctx, req.(*AddProtoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_SubmitSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).SubmitSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/SubmitSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).SubmitSource(ctx, req.(*ProtocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(h2gproxy.StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProtoRendererServiceServer).StreamHTTP(m, &protoRendererServiceStreamHTTPServer{stream})
}

type ProtoRendererService_StreamHTTPServer interface {
	Send(*h2gproxy.StreamDataResponse) error
	grpc.ServerStream
}

type protoRendererServiceStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *protoRendererServiceStreamHTTPServer) Send(m *h2gproxy.StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ProtoRendererService_GetPackages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetPackages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetPackages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetPackages(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetPackageByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetPackageByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetPackageByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetPackageByID(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetFilesJavaClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetFilesJavaClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetFilesJavaClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetFilesJavaClass(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetFilesGO_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetFilesGO(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetFilesGO",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetFilesGO(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetFilesProto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetFilesProto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetFilesProto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetFilesProto(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetFilesPython_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetFilesPython(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetFilesPython",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetFilesPython(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetFilesNanoPB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetFilesNanoPB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetFilesNanoPB",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetFilesNanoPB(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetFile(ctx, req.(*FileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetVersion(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_CompileFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).CompileFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/CompileFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).CompileFile(ctx, req.(*CompileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_ListSourceFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).ListSourceFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/ListSourceFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).ListSourceFiles(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/DeleteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).DeleteFile(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_FindServiceByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindServiceByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).FindServiceByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/FindServiceByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).FindServiceByName(ctx, req.(*FindServiceByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_FindServiceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).FindServiceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/FindServiceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).FindServiceByID(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_GetFilesGoByPackageName_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PackageName)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProtoRendererServiceServer).GetFilesGoByPackageName(m, &protoRendererServiceGetFilesGoByPackageNameServer{stream})
}

type ProtoRendererService_GetFilesGoByPackageNameServer interface {
	Send(*FileStream) error
	grpc.ServerStream
}

type protoRendererServiceGetFilesGoByPackageNameServer struct {
	grpc.ServerStream
}

func (x *protoRendererServiceGetFilesGoByPackageNameServer) Send(m *FileStream) error {
	return x.ServerStream.SendMsg(m)
}

func _ProtoRendererService_GetPackageByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).GetPackageByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/GetPackageByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).GetPackageByName(ctx, req.(*PackageName))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProtoRendererService_FindPackageByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProtoRendererServiceServer).FindPackageByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protorenderer.ProtoRendererService/FindPackageByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProtoRendererServiceServer).FindPackageByName(ctx, req.(*PackageName))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProtoRendererService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protorenderer.ProtoRendererService",
	HandlerType: (*ProtoRendererServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateProto",
			Handler:    _ProtoRendererService_UpdateProto_Handler,
		},
		{
			MethodName: "MiniParser",
			Handler:    _ProtoRendererService_MiniParser_Handler,
		},
		{
			MethodName: "SubmitSource",
			Handler:    _ProtoRendererService_SubmitSource_Handler,
		},
		{
			MethodName: "GetPackages",
			Handler:    _ProtoRendererService_GetPackages_Handler,
		},
		{
			MethodName: "GetPackageByID",
			Handler:    _ProtoRendererService_GetPackageByID_Handler,
		},
		{
			MethodName: "GetFilesJavaClass",
			Handler:    _ProtoRendererService_GetFilesJavaClass_Handler,
		},
		{
			MethodName: "GetFilesGO",
			Handler:    _ProtoRendererService_GetFilesGO_Handler,
		},
		{
			MethodName: "GetFilesProto",
			Handler:    _ProtoRendererService_GetFilesProto_Handler,
		},
		{
			MethodName: "GetFilesPython",
			Handler:    _ProtoRendererService_GetFilesPython_Handler,
		},
		{
			MethodName: "GetFilesNanoPB",
			Handler:    _ProtoRendererService_GetFilesNanoPB_Handler,
		},
		{
			MethodName: "GetFile",
			Handler:    _ProtoRendererService_GetFile_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _ProtoRendererService_GetVersion_Handler,
		},
		{
			MethodName: "CompileFile",
			Handler:    _ProtoRendererService_CompileFile_Handler,
		},
		{
			MethodName: "ListSourceFiles",
			Handler:    _ProtoRendererService_ListSourceFiles_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _ProtoRendererService_DeleteFile_Handler,
		},
		{
			MethodName: "FindServiceByName",
			Handler:    _ProtoRendererService_FindServiceByName_Handler,
		},
		{
			MethodName: "FindServiceByID",
			Handler:    _ProtoRendererService_FindServiceByID_Handler,
		},
		{
			MethodName: "GetPackageByName",
			Handler:    _ProtoRendererService_GetPackageByName_Handler,
		},
		{
			MethodName: "FindPackageByName",
			Handler:    _ProtoRendererService_FindPackageByName_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHTTP",
			Handler:       _ProtoRendererService_StreamHTTP_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFilesGoByPackageName",
			Handler:       _ProtoRendererService_GetFilesGoByPackageName_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/protorenderer/protorenderer.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/protorenderer/protorenderer.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1687 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0xdb, 0x6e, 0xdb, 0x46,
	0x1a, 0x5e, 0x4a, 0x94, 0x2d, 0xfd, 0xf2, 0x41, 0x9e, 0x35, 0x12, 0xad, 0xe2, 0xf5, 0x0a, 0xdc,
	0x20, 0x6b, 0x04, 0x59, 0xd9, 0xab, 0x05, 0x76, 0xdb, 0x24, 0x40, 0x6b, 0x89, 0xb6, 0xa3, 0xd4,
	0x91, 0x15, 0xfa, 0x80, 0xb6, 0x40, 0x51, 0x30, 0xd2, 0x44, 0x21, 0x22, 0x71, 0x14, 0x92, 0x4a,
	0xac, 0x27, 0x28, 0x8a, 0x02, 0xbd, 0x29, 0xfa, 0x12, 0x05, 0x7a, 0xd1, 0x9b, 0x00, 0x7d, 0x9a,
	0x3e, 0x43, 0xdf, 0xa0, 0x98, 0x13, 0x39, 0x3c, 0x48, 0xb6, 0xdb, 0x5e, 0x18, 0xe6, 0xfc, 0xa7,
	0xf9, 0xe7, 0x9b, 0xff, 0x34, 0x82, 0xf6, 0xc4, 0x23, 0x01, 0xf1, 0x77, 0x87, 0x64, 0x64, 0xbb,
	0xc3, 0x46, 0x9f, 0xb8, 0x9e, 0x3d, 0x78, 0x47, 0xc8, 0xa0, 0xe1, 0xe2, 0x60, 0xd7, 0x9e, 0x38,
	0xfe, 0x2e, 0x93, 0xf0, 0xb0, 0x3b, 0xc0, 0x1e, 0xf6, 0xe2, 0xab, 0x06, 0x5b, 0xa1, 0xd5, 0x18,
	0xb1, 0xd6, 0x58, 0x60, 0xac, 0x4f, 0xc6, 0x63, 0xe2, 0x8a, 0x7f, 0x5c, 0xbd, 0xd6, 0x5c, 0x20,
	0xff, 0xaa, 0x39, 0x9c, 0x78, 0xe4, 0x72, 0x16, 0x7e, 0x08, 0x9d, 0xfa, 0x90, 0x90, 0xe1, 0x08,
	0x73, 0x77, 0x5e, 0x4c, 0x5f, 0xee, 0x0e, 0xb0, 0xdf, 0xf7, 0x9c, 0x49, 0x40, 0x84, 0x53, 0xc6,
	0x39, 0x94, 0xcd, 0x56, 0x8f, 0x7e, 0x1e, 0x3a, 0x23, 0x8c, 0xd6, 0x20, 0xd7, 0x31, 0xab, 0x5a,
	0x5d, 0xdb, 0xd1, 0xad, 0x5c, 0xc7, 0x44, 0x08, 0xf4, 0xae, 0x3d, 0xc6, 0xd5, 0x5c, 0x5d, 0xdb,
	0x29, 0x59, 0xec, 0x1b, 0x19, 0xb0, 0x62, 0xe1, 0x09, 0xf1, 0x9d, 0x80, 0x78, 0xb3, 0x8e, 0x59,
	0xcd, 0x33, 0xe9, 0x18, 0xcd, 0xf8, 0x37, 0x94, 0x7a, 0xd8, 0xf3, 0x1d, 0x3f, 0xe8, 0x98, 0x29,
	0xa3, 0x15, 0xc8, 0x7f, 0x82, 0x67, 0xc2, 0x26, 0xfd, 0x34, 0xfa, 0xb0, 0xbe, 0x3f, 0x18, 0x30,
	0x37, 0x2c, 0xfc, 0x66, 0x8a, 0xfd, 0x20, 0xdc, 0x59, 0x53, 0x76, 0xae, 0xc2, 0x72, 0x9b, 0xb8,
	0x01, 0x76, 0x03, 0xa1, 0x2c, 0x97, 0xd7, 0xf2, 0xe9, 0x07, 0x0d, 0x2a, 0xd1, 0x2e, 0xfe, 0x84,
	0xb8, 0x3e, 0x33, 0x79, 0x41, 0x1d, 0x25, 0xae, 0x70, 0x50, 0x2e, 0xa9, 0x49, 0x26, 0x2a, 0xd9,
	0x39, 0x6e, 0x52, 0xa5, 0xa1, 0x2d, 0x28, 0x1d, 0x91, 0x9e, 0xdd, 0x7f, 0x6d, 0x0f, 0x31, 0xdb,
	0xb3, 0x64, 0x45, 0x04, 0x54, 0x87, 0xf2, 0x53, 0xfb, 0xad, 0x2d, 0xf9, 0x3a, 0xe3, 0xab, 0x24,
	0xba, 0x7b, 0x67, 0x3c, 0x21, 0x5e, 0xe0, 0x57, 0x0b, 0xf5, 0x3c, 0x3d, 0x90, 0x58, 0x1a, 0xbf,
	0x6a, 0x50, 0x8a, 0xae, 0x25, 0xb6, 0x8f, 0x76, 0xc5, 0x3e, 0xb9, 0xf4, 0x3e, 0x35, 0x28, 0x52,
	0x3b, 0x2e, 0x05, 0x94, 0xbb, 0x19, 0xae, 0x55, 0x50, 0xf5, 0x38, 0xa8, 0x73, 0xbd, 0x43, 0x7b,
	0xa0, 0x3f, 0xc3, 0x81, 0x5d, 0x5d, 0xaa, 0x6b, 0x3b, 0xe5, 0xe6, 0x56, 0x23, 0x1e, 0xee, 0x94,
	0x15, 0xfa, 0x6e, 0x31, 0xc9, 0xd4, 0x05, 0x2d, 0x67, 0x5c, 0xd0, 0x97, 0xb0, 0x1a, 0x53, 0xa5,
	0xc7, 0x16, 0x27, 0x10, 0xf1, 0x53, 0xb2, 0x22, 0x02, 0xda, 0x83, 0x65, 0xf5, 0xc8, 0xe5, 0xe6,
	0xad, 0x84, 0x1f, 0x82, 0x6b, 0x49, 0x31, 0xe3, 0x47, 0x2d, 0x54, 0x51, 0x82, 0xb2, 0x34, 0x37,
	0xd2, 0x6f, 0xc1, 0x52, 0xcf, 0xc3, 0x2f, 0x9d, 0x4b, 0x01, 0x9a, 0x58, 0xa1, 0x26, 0x14, 0x4f,
	0xb1, 0xf7, 0xd6, 0xe9, 0x63, 0xbf, 0xaa, 0xd7, 0xf3, 0x19, 0x5b, 0x0b, 0xb6, 0x15, 0xca, 0x51,
	0x9d, 0x67, 0xd8, 0xf7, 0xed, 0x21, 0xe6, 0x68, 0xa6, 0x75, 0x04, 0xdb, 0x0a, 0xe5, 0x8c, 0x2f,
	0x60, 0x43, 0xb8, 0x7b, 0xe8, 0xb8, 0x03, 0x0b, 0xfb, 0xd3, 0x51, 0x40, 0x9d, 0x3a, 0xb8, 0x74,
	0xfc, 0xc0, 0x67, 0xce, 0x17, 0x2d, 0xb1, 0xfa, 0x1d, 0x70, 0xfc, 0xa4, 0xc1, 0xb2, 0xf0, 0xef,
	0x5a, 0x70, 0xdc, 0x03, 0xdd, 0xea, 0xb5, 0xfd, 0x6a, 0x9e, 0xb9, 0x8f, 0x12, 0xe6, 0xad, 0x5e,
	0xdb, 0x62, 0x7c, 0x1e, 0x51, 0xe3, 0x71, 0x2c, 0xa2, 0xd8, 0x32, 0x7e, 0xa1, 0x85, 0xe4, 0x85,
	0x26, 0x63, 0x64, 0x29, 0x23, 0x46, 0x7e, 0xd1, 0x20, 0x6f, 0xf5, 0xda, 0xd7, 0xf2, 0xf7, 0x01,
	0x14, 0x3a, 0xee, 0x64, 0x1a, 0xb0, 0xdb, 0x9b, 0x8f, 0x37, 0x17, 0x42, 0x0d, 0x58, 0x3a, 0x99,
	0x06, 0x54, 0x5c, 0x5f, 0x28, 0x2e, 0xa4, 0xd4, 0x53, 0x16, 0x52, 0xa7, 0x14, 0xb0, 0x8a, 0x43,
	0x94, 0xac, 0x88, 0x80, 0xb6, 0x01, 0x4c, 0x3c, 0xf1, 0x70, 0xdf, 0x0e, 0xf0, 0x80, 0xe5, 0x41,
	0xd1, 0x52, 0x28, 0xc6, 0x77, 0x1a, 0x2c, 0x8b, 0xbd, 0xae, 0x75, 0x4a, 0xc5, 0x8f, 0xfc, 0x02,
	0xb4, 0xf5, 0x24, 0xda, 0x0f, 0x60, 0xe9, 0xd0, 0xc1, 0xa3, 0x81, 0x0c, 0xc7, 0xcd, 0xc4, 0x79,
	0x19, 0xd3, 0x12, 0x32, 0xc6, 0x37, 0x39, 0x28, 0xb0, 0xcf, 0x6b, 0xf9, 0x84, 0x40, 0x3f, 0x9b,
	0x4d, 0x64, 0xad, 0x61, 0xdf, 0xd4, 0x9b, 0x83, 0xcb, 0xc0, 0xb3, 0x19, 0x43, 0x78, 0x13, 0x12,
	0x68, 0x85, 0xb2, 0xf0, 0x04, 0x33, 0x4c, 0x0a, 0x0c, 0x93, 0x70, 0xcd, 0x79, 0x6f, 0xa6, 0x8e,
	0x87, 0x07, 0x0c, 0x4e, 0xc6, 0xe3, 0x6b, 0xca, 0x3b, 0x99, 0x04, 0x0e, 0x71, 0xed, 0x91, 0xc0,
	0x32, 0x5c, 0xab, 0xc8, 0x14, 0x53, 0xc8, 0x08, 0x88, 0x3b, 0x66, 0xb5, 0xc4, 0x7d, 0x09, 0x09,
	0xb4, 0x9e, 0x8a, 0x05, 0x3b, 0x18, 0xf0, 0x7a, 0xaa, 0x90, 0x0c, 0x13, 0x2a, 0x21, 0x90, 0xb2,
	0x61, 0x55, 0xa3, 0xfc, 0xe3, 0xe0, 0x84, 0xa5, 0x26, 0x2a, 0x23, 0x39, 0xb5, 0x8c, 0x18, 0x9b,
	0x14, 0xc9, 0x24, 0x9e, 0x86, 0x05, 0x95, 0xd0, 0x15, 0x69, 0x7b, 0x71, 0x21, 0x4c, 0xf8, 0x9b,
	0x4b, 0xfb, 0x7b, 0x17, 0x56, 0x64, 0xbd, 0x3f, 0x76, 0xfc, 0x00, 0x6d, 0xd2, 0xcb, 0x1c, 0x61,
	0x5a, 0x42, 0x68, 0x5d, 0xe7, 0x0b, 0x1a, 0x79, 0x65, 0x56, 0xb2, 0xc5, 0xae, 0xbb, 0xc9, 0x5d,
	0xcb, 0xcd, 0x8d, 0x44, 0x90, 0x74, 0x4c, 0xd5, 0x11, 0xb5, 0xcd, 0xe4, 0x12, 0x6d, 0xe6, 0xff,
	0x50, 0x6c, 0x93, 0xf1, 0xc4, 0x19, 0x61, 0x8f, 0x85, 0xc5, 0x5a, 0xf3, 0x4e, 0xc2, 0x96, 0x64,
	0xd3, 0x78, 0xb0, 0x42, 0x61, 0xc3, 0x04, 0x9d, 0x35, 0x03, 0xa5, 0x4f, 0x51, 0x5f, 0x56, 0xe6,
	0x37, 0xff, 0x5c, 0x46, 0xdd, 0xf8, 0x4a, 0x0b, 0x1b, 0xfd, 0x82, 0x9e, 0xbf, 0x05, 0x25, 0xbe,
	0xaf, 0xe3, 0x0e, 0x99, 0x99, 0xa2, 0x15, 0x11, 0x28, 0xce, 0x5d, 0x7c, 0x19, 0x48, 0x5d, 0x3e,
	0x63, 0xa8, 0xa4, 0xd4, 0xcc, 0xa0, 0xa7, 0x67, 0x06, 0xe3, 0x1d, 0xac, 0xb2, 0x75, 0x5f, 0xc2,
	0x5c, 0x87, 0xf2, 0x05, 0xf6, 0x9c, 0x97, 0xb3, 0x33, 0xf2, 0x1a, 0xbb, 0xe2, 0x7a, 0x55, 0x12,
	0x32, 0x01, 0xc2, 0xa6, 0xe8, 0x57, 0x73, 0x2c, 0x5d, 0xef, 0x36, 0xf8, 0x6c, 0xd7, 0x90, 0xb3,
	0x5d, 0x83, 0x72, 0xcd, 0x70, 0xbe, 0xe3, 0x63, 0x8e, 0xa2, 0x67, 0x7c, 0x4d, 0xaf, 0x77, 0x64,
	0x07, 0x7f, 0x46, 0x07, 0x4c, 0x42, 0xae, 0xa7, 0x21, 0x8f, 0x45, 0x43, 0x21, 0x1e, 0x0d, 0x46,
	0x07, 0xd6, 0x15, 0x57, 0x58, 0x4c, 0xfe, 0x0f, 0x8a, 0x62, 0xc9, 0xc3, 0xb2, 0xdc, 0xac, 0x25,
	0x2b, 0x52, 0xa4, 0x61, 0x85, 0xb2, 0xc6, 0xf7, 0x1a, 0xac, 0x89, 0x60, 0x91, 0x88, 0x3e, 0x49,
	0x8d, 0x93, 0x22, 0x7c, 0xb7, 0x13, 0x16, 0x13, 0x52, 0x56, 0x6a, 0x0a, 0xfd, 0x50, 0x06, 0x04,
	0xf6, 0x38, 0xf0, 0x57, 0x84, 0x6d, 0x24, 0x6d, 0x7c, 0xab, 0xc1, 0x6a, 0xe8, 0x17, 0xeb, 0xdc,
	0xf7, 0x60, 0xed, 0x94, 0x4c, 0xbd, 0x3e, 0x0e, 0x61, 0xe1, 0xe0, 0x27, 0xa8, 0x14, 0x5c, 0xa1,
	0x78, 0xe0, 0x79, 0xc4, 0x13, 0x17, 0x12, 0xa3, 0xa1, 0xff, 0xc8, 0x0c, 0xe6, 0xcd, 0x78, 0x8e,
	0x53, 0x03, 0x96, 0xce, 0x22, 0xbd, 0xdf, 0x6b, 0xa1, 0x5d, 0x46, 0xa7, 0x29, 0x79, 0x6c, 0xbb,
	0xc3, 0xa9, 0x2c, 0x59, 0xf4, 0x6c, 0xe2, 0xc9, 0xd1, 0xf3, 0xc8, 0xd0, 0xb3, 0xc7, 0x63, 0xc7,
	0x1d, 0x4a, 0x11, 0x2b, 0x14, 0x5e, 0x98, 0xe7, 0x4a, 0x9a, 0xe6, 0xe3, 0x69, 0xaa, 0x56, 0x00,
	0xfd, 0x26, 0x15, 0xe0, 0x9f, 0xb0, 0x6a, 0xe2, 0x11, 0x0e, 0xf0, 0x82, 0xb7, 0x81, 0xd1, 0x80,
	0x2a, 0x1d, 0x92, 0x44, 0x9f, 0x6d, 0xcd, 0x28, 0x71, 0x91, 0x7c, 0x07, 0xca, 0x42, 0x96, 0x45,
	0xdf, 0x43, 0x65, 0xa4, 0xe3, 0xd1, 0xb7, 0x3d, 0x67, 0xa4, 0x13, 0x2f, 0x87, 0x68, 0xb4, 0x33,
	0x7e, 0xd6, 0x60, 0x3d, 0xc1, 0xa5, 0xd3, 0x98, 0x20, 0x89, 0xd0, 0x9b, 0x37, 0x21, 0x86, 0x13,
	0xd8, 0x8d, 0xe7, 0x37, 0x5a, 0x38, 0xc4, 0x67, 0x37, 0x1a, 0xec, 0x55, 0x92, 0x22, 0x71, 0xf8,
	0xdc, 0xec, 0xca, 0x17, 0x88, 0x42, 0x32, 0x76, 0x61, 0x8e, 0x82, 0x02, 0x98, 0x4a, 0x32, 0x5a,
	0x00, 0xf4, 0xae, 0x4f, 0x03, 0x0f, 0xdb, 0xe3, 0x58, 0x24, 0x68, 0xe9, 0x48, 0xe8, 0xd9, 0xb3,
	0x11, 0xb1, 0x07, 0xec, 0x40, 0x2b, 0x96, 0x5c, 0xde, 0xff, 0x3c, 0x0c, 0x44, 0x76, 0xd5, 0x68,
	0x15, 0x4a, 0xe7, 0x5d, 0xf3, 0xe0, 0xb0, 0xd3, 0x3d, 0x30, 0x2b, 0x7f, 0x41, 0x00, 0x4b, 0x47,
	0x27, 0xc7, 0xfb, 0xdd, 0xa3, 0x8a, 0x86, 0x8a, 0xa0, 0x3f, 0xdd, 0xbf, 0xd8, 0xaf, 0xe4, 0x28,
	0xb5, 0xf7, 0xd9, 0xd9, 0x93, 0x93, 0x6e, 0x25, 0x4f, 0xbf, 0xbb, 0xfb, 0xdd, 0x93, 0x5e, 0xab,
	0xa2, 0x53, 0xe5, 0x76, 0xef, 0xf8, 0xfc, 0x94, 0xfe, 0x55, 0x0a, 0xcd, 0xf7, 0x65, 0xd8, 0x14,
	0x29, 0xcc, 0x71, 0x93, 0xf8, 0x76, 0xa1, 0x7c, 0x3e, 0x19, 0xd8, 0x01, 0x66, 0x5c, 0x74, 0x45,
	0x29, 0xa8, 0xfd, 0x63, 0x2e, 0x5f, 0xdc, 0xf0, 0x21, 0xc0, 0x33, 0xc7, 0x75, 0x7a, 0xb6, 0xe7,
	0x63, 0xef, 0x4a, 0x73, 0xd5, 0xe4, 0x65, 0x86, 0x8f, 0x9c, 0x87, 0xb0, 0x72, 0x3a, 0x7d, 0x31,
	0x76, 0x02, 0x5e, 0x05, 0xd0, 0x56, 0x96, 0xa4, 0x6c, 0x16, 0xb5, 0x15, 0x99, 0xa1, 0x17, 0xc4,
	0x19, 0xa0, 0x03, 0x00, 0x7e, 0x11, 0x4f, 0xce, 0xce, 0x7a, 0xe8, 0x76, 0x23, 0x7c, 0xfe, 0x73,
	0xaa, 0x54, 0xda, 0x4a, 0x32, 0x4c, 0x3b, 0xb0, 0xe5, 0x41, 0xf6, 0x34, 0xf4, 0x08, 0xca, 0x47,
	0x58, 0x96, 0x56, 0x1f, 0xc5, 0xf6, 0xa8, 0x6d, 0xcf, 0xaf, 0xc2, 0x2c, 0x73, 0x1e, 0xc1, 0x5a,
	0xa4, 0xdc, 0xa2, 0x85, 0x3f, 0x3d, 0x24, 0xd4, 0xe6, 0xc4, 0x32, 0x6a, 0xc3, 0xc6, 0x11, 0x0e,
	0x58, 0x7d, 0xa2, 0xef, 0xd5, 0xf6, 0xc8, 0xf6, 0xfd, 0x2c, 0xfd, 0x3b, 0xa9, 0xe1, 0x54, 0x99,
	0x66, 0x1e, 0x03, 0x48, 0x23, 0x47, 0x27, 0x37, 0xd6, 0xfe, 0x08, 0x56, 0xa5, 0x36, 0x8f, 0x8c,
	0x9b, 0x1a, 0xf8, 0x98, 0x01, 0xc0, 0x0d, 0xcc, 0x82, 0x57, 0xc4, 0xfd, 0x23, 0x16, 0xba, 0xb6,
	0x4b, 0x7a, 0xad, 0x1b, 0x5b, 0x78, 0x08, 0xcb, 0xc2, 0x02, 0xaa, 0x65, 0xc8, 0xc9, 0x40, 0xf8,
	0x6b, 0x06, 0x0f, 0x35, 0x19, 0x7c, 0x72, 0x84, 0x89, 0x5f, 0x7e, 0xf2, 0xde, 0xa4, 0xd4, 0x53,
	0x28, 0x8b, 0x0c, 0x66, 0x26, 0xfe, 0x9e, 0x5d, 0xc8, 0xa3, 0xf8, 0x9b, 0xc3, 0x66, 0x6d, 0xf1,
	0x31, 0xac, 0xd3, 0x33, 0x44, 0x4d, 0x30, 0x19, 0x81, 0x0b, 0x4f, 0xfe, 0x01, 0x7d, 0x4e, 0xd1,
	0xe6, 0xc0, 0x7f, 0x31, 0x48, 0x88, 0xc6, 0xfa, 0x46, 0x22, 0x79, 0x3e, 0x85, 0x8d, 0x54, 0xc7,
	0x40, 0xff, 0x4a, 0xed, 0x95, 0xdd, 0x53, 0x6a, 0xb5, 0xec, 0x7a, 0xce, 0x7c, 0x32, 0x61, 0x3d,
	0xa6, 0x97, 0x9d, 0x13, 0x57, 0x34, 0x18, 0x64, 0xc1, 0xed, 0x30, 0xac, 0x49, 0x6b, 0xa6, 0x96,
	0xe9, 0x5a, 0x76, 0x3a, 0x51, 0x5e, 0xed, 0x6f, 0x19, 0x68, 0xf1, 0xac, 0xdf, 0xd3, 0xd0, 0x21,
	0x54, 0xd4, 0x64, 0xbd, 0xd2, 0xd8, 0xbc, 0xbc, 0x7d, 0xce, 0xb1, 0xbb, 0xbe, 0xa1, 0x7a, 0x36,
	0x2f, 0xfa, 0x5d, 0xa3, 0x75, 0x1f, 0x76, 0x5c, 0x1c, 0xa8, 0x3f, 0x6f, 0x8a, 0x1f, 0x3c, 0xed,
	0x89, 0xe3, 0xc7, 0xb5, 0x5f, 0x2c, 0xb1, 0xe5, 0x7f, 0x7f, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xbb,
	0x88, 0x80, 0x8a, 0x98, 0x15, 0x00, 0x00,
}
