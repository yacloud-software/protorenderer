// Code generated by protoc-gen-go.
// source: golang.lakeparime.com/apis/powernode/powernode.proto
// DO NOT EDIT!

/*
Package powernode is a generated protocol buffer package.

It is generated from these files:
	golang.lakeparime.com/apis/powernode/powernode.proto

It has these top-level messages:
	StateCommand
	StateCommandList
	TransitionList
	TransitionLog
	MinerID
	MinerStateMachine
	MinerStateList
	DeploymentID
	GRPCResponse
	MinerRequest
	CurrentState
	Hashboard
	MinerStates
	MinerState
	MinerIP
	MinerConfigResponse
	MinerConfigResponseList
	MinerConfigTemplate
	PoolConfig
	PowerMatchingPowerAlgorithmConfig
	ManualPowerAlgorithmConfig
*/
package powernode

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PowerAlgorithm int32

const (
	PowerAlgorithm_UNDEFINED PowerAlgorithm = 0
	PowerAlgorithm_MATCHING  PowerAlgorithm = 1
	PowerAlgorithm_MANUAL    PowerAlgorithm = 2
)

var PowerAlgorithm_name = map[int32]string{
	0: "UNDEFINED",
	1: "MATCHING",
	2: "MANUAL",
}
var PowerAlgorithm_value = map[string]int32{
	"UNDEFINED": 0,
	"MATCHING":  1,
	"MANUAL":    2,
}

func (x PowerAlgorithm) String() string {
	return proto.EnumName(PowerAlgorithm_name, int32(x))
}
func (PowerAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type HashingStatus int32

const (
	HashingStatus_UNKNOWN  HashingStatus = 0
	HashingStatus_ACTIVE   HashingStatus = 1
	HashingStatus_IDLE     HashingStatus = 2
	HashingStatus_STARTING HashingStatus = 3
	HashingStatus_ERROR    HashingStatus = 4
	HashingStatus_STOPPING HashingStatus = 5
)

var HashingStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "ACTIVE",
	2: "IDLE",
	3: "STARTING",
	4: "ERROR",
	5: "STOPPING",
}
var HashingStatus_value = map[string]int32{
	"UNKNOWN":  0,
	"ACTIVE":   1,
	"IDLE":     2,
	"STARTING": 3,
	"ERROR":    4,
	"STOPPING": 5,
}

func (x HashingStatus) String() string {
	return proto.EnumName(HashingStatus_name, int32(x))
}
func (HashingStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type StateCommand struct {
	Name             string        `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	MinerID          uint64        `protobuf:"varint,2,opt,name=MinerID" json:"MinerID,omitempty"`
	MinerIP          string        `protobuf:"bytes,3,opt,name=MinerIP" json:"MinerIP,omitempty"`
	MaxRuntime       uint32        `protobuf:"varint,4,opt,name=MaxRuntime" json:"MaxRuntime,omitempty"`
	LastExecuted     uint32        `protobuf:"varint,5,opt,name=LastExecuted" json:"LastExecuted,omitempty"`
	ExecutionCounter uint32        `protobuf:"varint,6,opt,name=ExecutionCounter" json:"ExecutionCounter,omitempty"`
	OnError          *StateCommand `protobuf:"bytes,7,opt,name=OnError" json:"OnError,omitempty"`
	OnSuccess        *StateCommand `protobuf:"bytes,8,opt,name=OnSuccess" json:"OnSuccess,omitempty"`
	MaxRepeat        uint32        `protobuf:"varint,9,opt,name=MaxRepeat" json:"MaxRepeat,omitempty"`
}

func (m *StateCommand) Reset()                    { *m = StateCommand{} }
func (m *StateCommand) String() string            { return proto.CompactTextString(m) }
func (*StateCommand) ProtoMessage()               {}
func (*StateCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StateCommand) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StateCommand) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

func (m *StateCommand) GetMinerIP() string {
	if m != nil {
		return m.MinerIP
	}
	return ""
}

func (m *StateCommand) GetMaxRuntime() uint32 {
	if m != nil {
		return m.MaxRuntime
	}
	return 0
}

func (m *StateCommand) GetLastExecuted() uint32 {
	if m != nil {
		return m.LastExecuted
	}
	return 0
}

func (m *StateCommand) GetExecutionCounter() uint32 {
	if m != nil {
		return m.ExecutionCounter
	}
	return 0
}

func (m *StateCommand) GetOnError() *StateCommand {
	if m != nil {
		return m.OnError
	}
	return nil
}

func (m *StateCommand) GetOnSuccess() *StateCommand {
	if m != nil {
		return m.OnSuccess
	}
	return nil
}

func (m *StateCommand) GetMaxRepeat() uint32 {
	if m != nil {
		return m.MaxRepeat
	}
	return 0
}

type StateCommandList struct {
	Commands []*StateCommand `protobuf:"bytes,1,rep,name=Commands" json:"Commands,omitempty"`
}

func (m *StateCommandList) Reset()                    { *m = StateCommandList{} }
func (m *StateCommandList) String() string            { return proto.CompactTextString(m) }
func (*StateCommandList) ProtoMessage()               {}
func (*StateCommandList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StateCommandList) GetCommands() []*StateCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

type TransitionList struct {
	Logs []*TransitionLog `protobuf:"bytes,1,rep,name=Logs" json:"Logs,omitempty"`
}

func (m *TransitionList) Reset()                    { *m = TransitionList{} }
func (m *TransitionList) String() string            { return proto.CompactTextString(m) }
func (*TransitionList) ProtoMessage()               {}
func (*TransitionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TransitionList) GetLogs() []*TransitionLog {
	if m != nil {
		return m.Logs
	}
	return nil
}

type TransitionLog struct {
	Started    uint32 `protobuf:"varint,1,opt,name=Started" json:"Started,omitempty"`
	Finished   uint32 `protobuf:"varint,2,opt,name=Finished" json:"Finished,omitempty"`
	Success    bool   `protobuf:"varint,3,opt,name=Success" json:"Success,omitempty"`
	Name       string `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty"`
	Executions uint32 `protobuf:"varint,5,opt,name=Executions" json:"Executions,omitempty"`
}

func (m *TransitionLog) Reset()                    { *m = TransitionLog{} }
func (m *TransitionLog) String() string            { return proto.CompactTextString(m) }
func (*TransitionLog) ProtoMessage()               {}
func (*TransitionLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TransitionLog) GetStarted() uint32 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *TransitionLog) GetFinished() uint32 {
	if m != nil {
		return m.Finished
	}
	return 0
}

func (m *TransitionLog) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *TransitionLog) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TransitionLog) GetExecutions() uint32 {
	if m != nil {
		return m.Executions
	}
	return 0
}

type MinerID struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *MinerID) Reset()                    { *m = MinerID{} }
func (m *MinerID) String() string            { return proto.CompactTextString(m) }
func (*MinerID) ProtoMessage()               {}
func (*MinerID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *MinerID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type MinerStateMachine struct {
	MinerID           uint64 `protobuf:"varint,1,opt,name=MinerID" json:"MinerID,omitempty"`
	CurrentTransition string `protobuf:"bytes,2,opt,name=CurrentTransition" json:"CurrentTransition,omitempty"`
	Started           uint32 `protobuf:"varint,3,opt,name=Started" json:"Started,omitempty"`
	LastStarted       uint32 `protobuf:"varint,4,opt,name=LastStarted" json:"LastStarted,omitempty"`
	LastStopped       uint32 `protobuf:"varint,5,opt,name=LastStopped" json:"LastStopped,omitempty"`
}

func (m *MinerStateMachine) Reset()                    { *m = MinerStateMachine{} }
func (m *MinerStateMachine) String() string            { return proto.CompactTextString(m) }
func (*MinerStateMachine) ProtoMessage()               {}
func (*MinerStateMachine) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *MinerStateMachine) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

func (m *MinerStateMachine) GetCurrentTransition() string {
	if m != nil {
		return m.CurrentTransition
	}
	return ""
}

func (m *MinerStateMachine) GetStarted() uint32 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *MinerStateMachine) GetLastStarted() uint32 {
	if m != nil {
		return m.LastStarted
	}
	return 0
}

func (m *MinerStateMachine) GetLastStopped() uint32 {
	if m != nil {
		return m.LastStopped
	}
	return 0
}

type MinerStateList struct {
	Miners []*MinerStateMachine `protobuf:"bytes,1,rep,name=Miners" json:"Miners,omitempty"`
}

func (m *MinerStateList) Reset()                    { *m = MinerStateList{} }
func (m *MinerStateList) String() string            { return proto.CompactTextString(m) }
func (*MinerStateList) ProtoMessage()               {}
func (*MinerStateList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MinerStateList) GetMiners() []*MinerStateMachine {
	if m != nil {
		return m.Miners
	}
	return nil
}

type DeploymentID struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *DeploymentID) Reset()                    { *m = DeploymentID{} }
func (m *DeploymentID) String() string            { return proto.CompactTextString(m) }
func (*DeploymentID) ProtoMessage()               {}
func (*DeploymentID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DeploymentID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type GRPCResponse struct {
	Success bool   `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message" json:"Message,omitempty"`
}

func (m *GRPCResponse) Reset()                    { *m = GRPCResponse{} }
func (m *GRPCResponse) String() string            { return proto.CompactTextString(m) }
func (*GRPCResponse) ProtoMessage()               {}
func (*GRPCResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GRPCResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GRPCResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type MinerRequest struct {
	Miners uint32 `protobuf:"varint,1,opt,name=Miners" json:"Miners,omitempty"`
	Manual bool   `protobuf:"varint,2,opt,name=Manual" json:"Manual,omitempty"`
}

func (m *MinerRequest) Reset()                    { *m = MinerRequest{} }
func (m *MinerRequest) String() string            { return proto.CompactTextString(m) }
func (*MinerRequest) ProtoMessage()               {}
func (*MinerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *MinerRequest) GetMiners() uint32 {
	if m != nil {
		return m.Miners
	}
	return 0
}

func (m *MinerRequest) GetManual() bool {
	if m != nil {
		return m.Manual
	}
	return false
}

// CurrentState contains all live data data about a deployment
type CurrentState struct {
	// ever increasing counter in watt hours of the power consumed by the deployment
	// For a specific meter - counter may reset on a new meter deployed
	CurrentSummationDeliveredToDeploymentWattHours float64 `protobuf:"fixed64,1,opt,name=CurrentSummationDeliveredToDeploymentWattHours" json:"CurrentSummationDeliveredToDeploymentWattHours,omitempty"`
	// how much power the deployment has consumed in past 5 seconds measured in watts
	DeploymentPowerConsumedInPast5SecondsWatts float64 `protobuf:"fixed64,2,opt,name=DeploymentPowerConsumedInPast5SecondsWatts" json:"DeploymentPowerConsumedInPast5SecondsWatts,omitempty"`
	// ever increasing counter in watt hours of the power generated by renewable energy source measured in watt hours
	CurrentSummationReceivedFromPowerSourceWattHours float64 `protobuf:"fixed64,3,opt,name=CurrentSummationReceivedFromPowerSourceWattHours" json:"CurrentSummationReceivedFromPowerSourceWattHours,omitempty"`
	// how much power has been exported from power source in past 5 seconds measured in watts
	PowerSourceGenerationInPast5SecondsWatts float64 `protobuf:"fixed64,4,opt,name=PowerSourceGenerationInPast5SecondsWatts" json:"PowerSourceGenerationInPast5SecondsWatts,omitempty"`
	// how much power that the deployment has drawn from the grid in past 5 seconds measured in watts
	PowerImportFromGridInPast5SecondsWatts float64 `protobuf:"fixed64,5,opt,name=PowerImportFromGridInPast5SecondsWatts" json:"PowerImportFromGridInPast5SecondsWatts,omitempty"`
	// the maximum amount of power in watts allowed to be exported to grid
	// ANM setpoint in Orkney
	ExportToGridLimitWatts float64 `protobuf:"fixed64,6,opt,name=ExportToGridLimitWatts" json:"ExportToGridLimitWatts,omitempty"`
	// the amount of power in Watt that could be produced by the power source
	// Potiential amount of power generated
	AvailablePowerWatts float64 `protobuf:"fixed64,7,opt,name=AvailablePowerWatts" json:"AvailablePowerWatts,omitempty"`
	// the average temp in celsius of the cold isle of the deployment in past 5 seconds
	ColdIsleTempInPast5SecondsCelsius float64 `protobuf:"fixed64,8,opt,name=ColdIsleTempInPast5SecondsCelsius" json:"ColdIsleTempInPast5SecondsCelsius,omitempty"`
	// the average temp in celsius of the hot isle of the deployment in past 5 seconds
	HotIsleTempInPast5SecondsCelsius float64 `protobuf:"fixed64,9,opt,name=HotIsleTempInPast5SecondsCelsius" json:"HotIsleTempInPast5SecondsCelsius,omitempty"`
	// the number of miners in the current deployment
	DeployedMiners uint32 `protobuf:"varint,10,opt,name=DeployedMiners" json:"DeployedMiners,omitempty"`
	// the number of miners in the current deployment that are enabled / reachable
	EnabledDeployedMiners uint32 `protobuf:"varint,11,opt,name=EnabledDeployedMiners" json:"EnabledDeployedMiners,omitempty"`
	// the number of miners in the current deployment that are actively mining
	ActiveDeployedMiners uint32 `protobuf:"varint,12,opt,name=ActiveDeployedMiners" json:"ActiveDeployedMiners,omitempty"`
	// the number of miners in the current deployment that are in idle mode
	IdleDeployedMiners uint32 `protobuf:"varint,13,opt,name=IdleDeployedMiners" json:"IdleDeployedMiners,omitempty"`
	// the number of miners in the current deployment that are unreachable / disconnected
	UnreachableDeployedMiners uint32 `protobuf:"varint,14,opt,name=UnreachableDeployedMiners" json:"UnreachableDeployedMiners,omitempty"`
	// the number of target number of miners in the current deployment set by Power Node
	TargetActiveDeployedMiners uint32 `protobuf:"varint,15,opt,name=TargetActiveDeployedMiners" json:"TargetActiveDeployedMiners,omitempty"`
	// The power algorithm currently running
	PowerAlgorithm PowerAlgorithm `protobuf:"varint,16,opt,name=PowerAlgorithm,enum=powernode.PowerAlgorithm" json:"PowerAlgorithm,omitempty"`
	// The power target to be consumed by the deployment
	TargetPowerSetpoint uint32 `protobuf:"varint,17,opt,name=TargetPowerSetpoint" json:"TargetPowerSetpoint,omitempty"`
}

func (m *CurrentState) Reset()                    { *m = CurrentState{} }
func (m *CurrentState) String() string            { return proto.CompactTextString(m) }
func (*CurrentState) ProtoMessage()               {}
func (*CurrentState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CurrentState) GetCurrentSummationDeliveredToDeploymentWattHours() float64 {
	if m != nil {
		return m.CurrentSummationDeliveredToDeploymentWattHours
	}
	return 0
}

func (m *CurrentState) GetDeploymentPowerConsumedInPast5SecondsWatts() float64 {
	if m != nil {
		return m.DeploymentPowerConsumedInPast5SecondsWatts
	}
	return 0
}

func (m *CurrentState) GetCurrentSummationReceivedFromPowerSourceWattHours() float64 {
	if m != nil {
		return m.CurrentSummationReceivedFromPowerSourceWattHours
	}
	return 0
}

func (m *CurrentState) GetPowerSourceGenerationInPast5SecondsWatts() float64 {
	if m != nil {
		return m.PowerSourceGenerationInPast5SecondsWatts
	}
	return 0
}

func (m *CurrentState) GetPowerImportFromGridInPast5SecondsWatts() float64 {
	if m != nil {
		return m.PowerImportFromGridInPast5SecondsWatts
	}
	return 0
}

func (m *CurrentState) GetExportToGridLimitWatts() float64 {
	if m != nil {
		return m.ExportToGridLimitWatts
	}
	return 0
}

func (m *CurrentState) GetAvailablePowerWatts() float64 {
	if m != nil {
		return m.AvailablePowerWatts
	}
	return 0
}

func (m *CurrentState) GetColdIsleTempInPast5SecondsCelsius() float64 {
	if m != nil {
		return m.ColdIsleTempInPast5SecondsCelsius
	}
	return 0
}

func (m *CurrentState) GetHotIsleTempInPast5SecondsCelsius() float64 {
	if m != nil {
		return m.HotIsleTempInPast5SecondsCelsius
	}
	return 0
}

func (m *CurrentState) GetDeployedMiners() uint32 {
	if m != nil {
		return m.DeployedMiners
	}
	return 0
}

func (m *CurrentState) GetEnabledDeployedMiners() uint32 {
	if m != nil {
		return m.EnabledDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetActiveDeployedMiners() uint32 {
	if m != nil {
		return m.ActiveDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetIdleDeployedMiners() uint32 {
	if m != nil {
		return m.IdleDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetUnreachableDeployedMiners() uint32 {
	if m != nil {
		return m.UnreachableDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetTargetActiveDeployedMiners() uint32 {
	if m != nil {
		return m.TargetActiveDeployedMiners
	}
	return 0
}

func (m *CurrentState) GetPowerAlgorithm() PowerAlgorithm {
	if m != nil {
		return m.PowerAlgorithm
	}
	return PowerAlgorithm_UNDEFINED
}

func (m *CurrentState) GetTargetPowerSetpoint() uint32 {
	if m != nil {
		return m.TargetPowerSetpoint
	}
	return 0
}

type Hashboard struct {
	// returns a list of the values of the temp sensors in celsius
	TempSensorsInCelsius []float64 `protobuf:"fixed64,1,rep,packed,name=TempSensorsInCelsius" json:"TempSensorsInCelsius,omitempty"`
	// returns the current voltage supplied to the hashboard
	Voltage float64 `protobuf:"fixed64,2,opt,name=Voltage" json:"Voltage,omitempty"`
	// returns the X-average frequency in Hertz
	FrequencyInHertz float64 `protobuf:"fixed64,3,opt,name=FrequencyInHertz" json:"FrequencyInHertz,omitempty"`
	// returns the theoretical max hashrate this hashboard can produce (Hashes/s)
	IdealHashrateHashesPerSecond float64 `protobuf:"fixed64,4,opt,name=IdealHashrateHashesPerSecond" json:"IdealHashrateHashesPerSecond,omitempty"`
	// returns the 5 second average hashrate in Hashes/s
	Hashrate5SecAverageHashesPerSecond float64 `protobuf:"fixed64,5,opt,name=Hashrate5SecAverageHashesPerSecond" json:"Hashrate5SecAverageHashesPerSecond,omitempty"`
	// ID field to identify between hashboards on the same miner
	ID uint32 `protobuf:"varint,6,opt,name=ID" json:"ID,omitempty"`
}

func (m *Hashboard) Reset()                    { *m = Hashboard{} }
func (m *Hashboard) String() string            { return proto.CompactTextString(m) }
func (*Hashboard) ProtoMessage()               {}
func (*Hashboard) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Hashboard) GetTempSensorsInCelsius() []float64 {
	if m != nil {
		return m.TempSensorsInCelsius
	}
	return nil
}

func (m *Hashboard) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *Hashboard) GetFrequencyInHertz() float64 {
	if m != nil {
		return m.FrequencyInHertz
	}
	return 0
}

func (m *Hashboard) GetIdealHashrateHashesPerSecond() float64 {
	if m != nil {
		return m.IdealHashrateHashesPerSecond
	}
	return 0
}

func (m *Hashboard) GetHashrate5SecAverageHashesPerSecond() float64 {
	if m != nil {
		return m.Hashrate5SecAverageHashesPerSecond
	}
	return 0
}

func (m *Hashboard) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type MinerStates struct {
	// Returns a repeated list of miners
	MinerStates []*MinerState `protobuf:"bytes,1,rep,name=MinerStates" json:"MinerStates,omitempty"`
}

func (m *MinerStates) Reset()                    { *m = MinerStates{} }
func (m *MinerStates) String() string            { return proto.CompactTextString(m) }
func (*MinerStates) ProtoMessage()               {}
func (*MinerStates) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *MinerStates) GetMinerStates() []*MinerState {
	if m != nil {
		return m.MinerStates
	}
	return nil
}

type MinerState struct {
	// Returns true if the device is on, false if it is off / unreachable
	DeviceStatus bool `protobuf:"varint,1,opt,name=DeviceStatus" json:"DeviceStatus,omitempty"`
	// Unix timestamp of when the query started
	UnixTimestamp uint64 `protobuf:"varint,2,opt,name=UnixTimestamp" json:"UnixTimestamp,omitempty"`
	// returns an enum based on hashing status on the miner
	HashingStatus HashingStatus `protobuf:"varint,3,opt,name=HashingStatus,enum=powernode.HashingStatus" json:"HashingStatus,omitempty"`
	// returns an enum based on the desired hashing status set by PowerNode
	DesiredHashingStatus HashingStatus `protobuf:"varint,4,opt,name=DesiredHashingStatus,enum=powernode.HashingStatus" json:"DesiredHashingStatus,omitempty"`
	// returns the 5 second average hashrate for the miner (Hashes/s)
	Hashrate5SecAverageHashesPerSecond float64 `protobuf:"fixed64,5,opt,name=Hashrate5SecAverageHashesPerSecond" json:"Hashrate5SecAverageHashesPerSecond,omitempty"`
	// returns the uptime of the miner, in seconds.
	// Uptime of CGMiner
	CGMinerUptimeInSeconds int32 `protobuf:"varint,6,opt,name=CGMinerUptimeInSeconds" json:"CGMinerUptimeInSeconds,omitempty"`
	// returns data about each specific hashboard on the miner
	Hashboards []*Hashboard `protobuf:"bytes,7,rep,name=Hashboards" json:"Hashboards,omitempty"`
	// returns the potential total max hashrate for whole miner (GH/s)
	IdealHashrateHashesPerSecond float64 `protobuf:"fixed64,8,opt,name=IdealHashrateHashesPerSecond" json:"IdealHashrateHashesPerSecond,omitempty"`
	// returns the average frequency from all hashboards (Hertz)
	AverageFrequencyHertz float64 `protobuf:"fixed64,9,opt,name=AverageFrequencyHertz" json:"AverageFrequencyHertz,omitempty"`
	// returns the pool url used by the miner
	PoolURL string `protobuf:"bytes,10,opt,name=PoolURL" json:"PoolURL,omitempty"`
	// returns the IPAddress of the miner
	MinerIPAddress *MinerIP `protobuf:"bytes,13,opt,name=MinerIPAddress" json:"MinerIPAddress,omitempty"`
	// returns the db MinerID for this miner
	MinerID uint64 `protobuf:"varint,14,opt,name=MinerID" json:"MinerID,omitempty"`
}

func (m *MinerState) Reset()                    { *m = MinerState{} }
func (m *MinerState) String() string            { return proto.CompactTextString(m) }
func (*MinerState) ProtoMessage()               {}
func (*MinerState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *MinerState) GetDeviceStatus() bool {
	if m != nil {
		return m.DeviceStatus
	}
	return false
}

func (m *MinerState) GetUnixTimestamp() uint64 {
	if m != nil {
		return m.UnixTimestamp
	}
	return 0
}

func (m *MinerState) GetHashingStatus() HashingStatus {
	if m != nil {
		return m.HashingStatus
	}
	return HashingStatus_UNKNOWN
}

func (m *MinerState) GetDesiredHashingStatus() HashingStatus {
	if m != nil {
		return m.DesiredHashingStatus
	}
	return HashingStatus_UNKNOWN
}

func (m *MinerState) GetHashrate5SecAverageHashesPerSecond() float64 {
	if m != nil {
		return m.Hashrate5SecAverageHashesPerSecond
	}
	return 0
}

func (m *MinerState) GetCGMinerUptimeInSeconds() int32 {
	if m != nil {
		return m.CGMinerUptimeInSeconds
	}
	return 0
}

func (m *MinerState) GetHashboards() []*Hashboard {
	if m != nil {
		return m.Hashboards
	}
	return nil
}

func (m *MinerState) GetIdealHashrateHashesPerSecond() float64 {
	if m != nil {
		return m.IdealHashrateHashesPerSecond
	}
	return 0
}

func (m *MinerState) GetAverageFrequencyHertz() float64 {
	if m != nil {
		return m.AverageFrequencyHertz
	}
	return 0
}

func (m *MinerState) GetPoolURL() string {
	if m != nil {
		return m.PoolURL
	}
	return ""
}

func (m *MinerState) GetMinerIPAddress() *MinerIP {
	if m != nil {
		return m.MinerIPAddress
	}
	return nil
}

func (m *MinerState) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

type MinerIP struct {
	// Returns the IPAddress of a miner
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress" json:"IPAddress,omitempty"`
}

func (m *MinerIP) Reset()                    { *m = MinerIP{} }
func (m *MinerIP) String() string            { return proto.CompactTextString(m) }
func (*MinerIP) ProtoMessage()               {}
func (*MinerIP) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MinerIP) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

type MinerConfigResponse struct {
	// Response sent back by miners when changing their configuration
	MinerIP *MinerIP `protobuf:"bytes,1,opt,name=MinerIP" json:"MinerIP,omitempty"`
	Status  bool     `protobuf:"varint,2,opt,name=Status" json:"Status,omitempty"`
}

func (m *MinerConfigResponse) Reset()                    { *m = MinerConfigResponse{} }
func (m *MinerConfigResponse) String() string            { return proto.CompactTextString(m) }
func (*MinerConfigResponse) ProtoMessage()               {}
func (*MinerConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *MinerConfigResponse) GetMinerIP() *MinerIP {
	if m != nil {
		return m.MinerIP
	}
	return nil
}

func (m *MinerConfigResponse) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type MinerConfigResponseList struct {
	Responses []*MinerConfigResponse `protobuf:"bytes,1,rep,name=Responses" json:"Responses,omitempty"`
}

func (m *MinerConfigResponseList) Reset()                    { *m = MinerConfigResponseList{} }
func (m *MinerConfigResponseList) String() string            { return proto.CompactTextString(m) }
func (*MinerConfigResponseList) ProtoMessage()               {}
func (*MinerConfigResponseList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *MinerConfigResponseList) GetResponses() []*MinerConfigResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

type MinerConfigTemplate struct {
	// The list of miners that this config should apply to
	MinerIPs []*MinerIP `protobuf:"bytes,1,rep,name=MinerIPs" json:"MinerIPs,omitempty"`
	// Templates for the default pool url, user and pass
	// Template info can be found in README
	PoolConfigs []*PoolConfig `protobuf:"bytes,2,rep,name=PoolConfigs" json:"PoolConfigs,omitempty"`
	// enables or disables the CGMiner API
	APIAllow bool `protobuf:"varint,3,opt,name=APIAllow" json:"APIAllow,omitempty"`
	// The port is to specify which port the miner rpc api is enabled on
	APIPort uint32 `protobuf:"varint,4,opt,name=APIPort" json:"APIPort,omitempty"`
}

func (m *MinerConfigTemplate) Reset()                    { *m = MinerConfigTemplate{} }
func (m *MinerConfigTemplate) String() string            { return proto.CompactTextString(m) }
func (*MinerConfigTemplate) ProtoMessage()               {}
func (*MinerConfigTemplate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *MinerConfigTemplate) GetMinerIPs() []*MinerIP {
	if m != nil {
		return m.MinerIPs
	}
	return nil
}

func (m *MinerConfigTemplate) GetPoolConfigs() []*PoolConfig {
	if m != nil {
		return m.PoolConfigs
	}
	return nil
}

func (m *MinerConfigTemplate) GetAPIAllow() bool {
	if m != nil {
		return m.APIAllow
	}
	return false
}

func (m *MinerConfigTemplate) GetAPIPort() uint32 {
	if m != nil {
		return m.APIPort
	}
	return 0
}

type PoolConfig struct {
	// Templates for the default pool url, user and pass
	// Template info can be found in README
	PoolURL      string `protobuf:"bytes,1,opt,name=PoolURL" json:"PoolURL,omitempty"`
	PoolUsername string `protobuf:"bytes,2,opt,name=PoolUsername" json:"PoolUsername,omitempty"`
	PoolPassword string `protobuf:"bytes,3,opt,name=PoolPassword" json:"PoolPassword,omitempty"`
}

func (m *PoolConfig) Reset()                    { *m = PoolConfig{} }
func (m *PoolConfig) String() string            { return proto.CompactTextString(m) }
func (*PoolConfig) ProtoMessage()               {}
func (*PoolConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *PoolConfig) GetPoolURL() string {
	if m != nil {
		return m.PoolURL
	}
	return ""
}

func (m *PoolConfig) GetPoolUsername() string {
	if m != nil {
		return m.PoolUsername
	}
	return ""
}

func (m *PoolConfig) GetPoolPassword() string {
	if m != nil {
		return m.PoolPassword
	}
	return ""
}

type PowerMatchingPowerAlgorithmConfig struct {
	// The margin to be used when determining the max power draw
	SafteyMargin float64 `protobuf:"fixed64,1,opt,name=SafteyMargin" json:"SafteyMargin,omitempty"`
	// The difference between two power setpoints that the HPCs should react to
	ReactionDifferenceThreshold float64 `protobuf:"fixed64,2,opt,name=ReactionDifferenceThreshold" json:"ReactionDifferenceThreshold,omitempty"`
}

func (m *PowerMatchingPowerAlgorithmConfig) Reset()         { *m = PowerMatchingPowerAlgorithmConfig{} }
func (m *PowerMatchingPowerAlgorithmConfig) String() string { return proto.CompactTextString(m) }
func (*PowerMatchingPowerAlgorithmConfig) ProtoMessage()    {}
func (*PowerMatchingPowerAlgorithmConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{19}
}

func (m *PowerMatchingPowerAlgorithmConfig) GetSafteyMargin() float64 {
	if m != nil {
		return m.SafteyMargin
	}
	return 0
}

func (m *PowerMatchingPowerAlgorithmConfig) GetReactionDifferenceThreshold() float64 {
	if m != nil {
		return m.ReactionDifferenceThreshold
	}
	return 0
}

type ManualPowerAlgorithmConfig struct {
	// Set the amount of power the deployment should use
	PowerSetpointWatts float64 `protobuf:"fixed64,1,opt,name=PowerSetpointWatts" json:"PowerSetpointWatts,omitempty"`
}

func (m *ManualPowerAlgorithmConfig) Reset()                    { *m = ManualPowerAlgorithmConfig{} }
func (m *ManualPowerAlgorithmConfig) String() string            { return proto.CompactTextString(m) }
func (*ManualPowerAlgorithmConfig) ProtoMessage()               {}
func (*ManualPowerAlgorithmConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ManualPowerAlgorithmConfig) GetPowerSetpointWatts() float64 {
	if m != nil {
		return m.PowerSetpointWatts
	}
	return 0
}

func init() {
	proto.RegisterType((*StateCommand)(nil), "powernode.StateCommand")
	proto.RegisterType((*StateCommandList)(nil), "powernode.StateCommandList")
	proto.RegisterType((*TransitionList)(nil), "powernode.TransitionList")
	proto.RegisterType((*TransitionLog)(nil), "powernode.TransitionLog")
	proto.RegisterType((*MinerID)(nil), "powernode.MinerID")
	proto.RegisterType((*MinerStateMachine)(nil), "powernode.MinerStateMachine")
	proto.RegisterType((*MinerStateList)(nil), "powernode.MinerStateList")
	proto.RegisterType((*DeploymentID)(nil), "powernode.DeploymentID")
	proto.RegisterType((*GRPCResponse)(nil), "powernode.GRPCResponse")
	proto.RegisterType((*MinerRequest)(nil), "powernode.MinerRequest")
	proto.RegisterType((*CurrentState)(nil), "powernode.CurrentState")
	proto.RegisterType((*Hashboard)(nil), "powernode.Hashboard")
	proto.RegisterType((*MinerStates)(nil), "powernode.MinerStates")
	proto.RegisterType((*MinerState)(nil), "powernode.MinerState")
	proto.RegisterType((*MinerIP)(nil), "powernode.MinerIP")
	proto.RegisterType((*MinerConfigResponse)(nil), "powernode.MinerConfigResponse")
	proto.RegisterType((*MinerConfigResponseList)(nil), "powernode.MinerConfigResponseList")
	proto.RegisterType((*MinerConfigTemplate)(nil), "powernode.MinerConfigTemplate")
	proto.RegisterType((*PoolConfig)(nil), "powernode.PoolConfig")
	proto.RegisterType((*PowerMatchingPowerAlgorithmConfig)(nil), "powernode.PowerMatchingPowerAlgorithmConfig")
	proto.RegisterType((*ManualPowerAlgorithmConfig)(nil), "powernode.ManualPowerAlgorithmConfig")
	proto.RegisterEnum("powernode.PowerAlgorithm", PowerAlgorithm_name, PowerAlgorithm_value)
	proto.RegisterEnum("powernode.HashingStatus", HashingStatus_name, HashingStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PowerNode service

type PowerNodeClient interface {
	// trip the circuit breaker
	TriggerCircuitBreaker(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// get list of transitions for a given miner
	GetTransitionList(ctx context.Context, in *MinerID, opts ...grpc.CallOption) (*TransitionList, error)
	// reset all states on all miners
	ResetStateMachine(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// get state for miners
	GetStateMachineStatus(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*StateCommandList, error)
	// get all currently known miners of minermgr, sorted
	GetMinerMgrMiners(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MinerStateList, error)
	// for testing, just set a certain number of miners to on
	SetNumberOfMiners(ctx context.Context, in *MinerRequest, opts ...grpc.CallOption) (*common.Void, error)
	// return information about powernode's state
	GetCurrentState(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CurrentState, error)
	// return information about Miners
	GetMinerStates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MinerStates, error)
	// set the current power algorithm to manual mode
	EnableManualPowerAlgorithm(ctx context.Context, in *ManualPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error)
	// set the current power algorithm to power matching mode
	EnablePowerMatchingPowerAlgorithm(ctx context.Context, in *PowerMatchingPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error)
	// using a list of miner IPs, sets their configs to match a template
	SetMinerConfigTemplate(ctx context.Context, in *MinerConfigTemplate, opts ...grpc.CallOption) (*MinerConfigResponseList, error)
	// Enable this copy of PowerNode
	EnablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error)
	// Disable this copy of PowerNode
	DisablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error)
	GetDeploymentID(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*DeploymentID, error)
}

type powerNodeClient struct {
	cc *grpc.ClientConn
}

func NewPowerNodeClient(cc *grpc.ClientConn) PowerNodeClient {
	return &powerNodeClient{cc}
}

func (c *powerNodeClient) TriggerCircuitBreaker(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/TriggerCircuitBreaker", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetTransitionList(ctx context.Context, in *MinerID, opts ...grpc.CallOption) (*TransitionList, error) {
	out := new(TransitionList)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetTransitionList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) ResetStateMachine(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/ResetStateMachine", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetStateMachineStatus(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*StateCommandList, error) {
	out := new(StateCommandList)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetStateMachineStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetMinerMgrMiners(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MinerStateList, error) {
	out := new(MinerStateList)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetMinerMgrMiners", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) SetNumberOfMiners(ctx context.Context, in *MinerRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/SetNumberOfMiners", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetCurrentState(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CurrentState, error) {
	out := new(CurrentState)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetCurrentState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetMinerStates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MinerStates, error) {
	out := new(MinerStates)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetMinerStates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) EnableManualPowerAlgorithm(ctx context.Context, in *ManualPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/EnableManualPowerAlgorithm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) EnablePowerMatchingPowerAlgorithm(ctx context.Context, in *PowerMatchingPowerAlgorithmConfig, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/EnablePowerMatchingPowerAlgorithm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) SetMinerConfigTemplate(ctx context.Context, in *MinerConfigTemplate, opts ...grpc.CallOption) (*MinerConfigResponseList, error) {
	out := new(MinerConfigResponseList)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/SetMinerConfigTemplate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) EnablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/EnablePowerNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) DisablePowerNode(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GRPCResponse, error) {
	out := new(GRPCResponse)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/DisablePowerNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerNodeClient) GetDeploymentID(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*DeploymentID, error) {
	out := new(DeploymentID)
	err := grpc.Invoke(ctx, "/powernode.PowerNode/GetDeploymentID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PowerNode service

type PowerNodeServer interface {
	// trip the circuit breaker
	TriggerCircuitBreaker(context.Context, *common.Void) (*common.Void, error)
	// get list of transitions for a given miner
	GetTransitionList(context.Context, *MinerID) (*TransitionList, error)
	// reset all states on all miners
	ResetStateMachine(context.Context, *common.Void) (*common.Void, error)
	// get state for miners
	GetStateMachineStatus(context.Context, *common.Void) (*StateCommandList, error)
	// get all currently known miners of minermgr, sorted
	GetMinerMgrMiners(context.Context, *common.Void) (*MinerStateList, error)
	// for testing, just set a certain number of miners to on
	SetNumberOfMiners(context.Context, *MinerRequest) (*common.Void, error)
	// return information about powernode's state
	GetCurrentState(context.Context, *common.Void) (*CurrentState, error)
	// return information about Miners
	GetMinerStates(context.Context, *common.Void) (*MinerStates, error)
	// set the current power algorithm to manual mode
	EnableManualPowerAlgorithm(context.Context, *ManualPowerAlgorithmConfig) (*GRPCResponse, error)
	// set the current power algorithm to power matching mode
	EnablePowerMatchingPowerAlgorithm(context.Context, *PowerMatchingPowerAlgorithmConfig) (*GRPCResponse, error)
	// using a list of miner IPs, sets their configs to match a template
	SetMinerConfigTemplate(context.Context, *MinerConfigTemplate) (*MinerConfigResponseList, error)
	// Enable this copy of PowerNode
	EnablePowerNode(context.Context, *common.Void) (*GRPCResponse, error)
	// Disable this copy of PowerNode
	DisablePowerNode(context.Context, *common.Void) (*GRPCResponse, error)
	GetDeploymentID(context.Context, *common.Void) (*DeploymentID, error)
}

func RegisterPowerNodeServer(s *grpc.Server, srv PowerNodeServer) {
	s.RegisterService(&_PowerNode_serviceDesc, srv)
}

func _PowerNode_TriggerCircuitBreaker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).TriggerCircuitBreaker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/TriggerCircuitBreaker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).TriggerCircuitBreaker(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetTransitionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetTransitionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetTransitionList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetTransitionList(ctx, req.(*MinerID))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_ResetStateMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).ResetStateMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/ResetStateMachine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).ResetStateMachine(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetStateMachineStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetStateMachineStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetStateMachineStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetStateMachineStatus(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetMinerMgrMiners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetMinerMgrMiners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetMinerMgrMiners",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetMinerMgrMiners(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_SetNumberOfMiners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).SetNumberOfMiners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/SetNumberOfMiners",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).SetNumberOfMiners(ctx, req.(*MinerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetCurrentState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetCurrentState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetCurrentState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetCurrentState(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetMinerStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetMinerStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetMinerStates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetMinerStates(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_EnableManualPowerAlgorithm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ManualPowerAlgorithmConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).EnableManualPowerAlgorithm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/EnableManualPowerAlgorithm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).EnableManualPowerAlgorithm(ctx, req.(*ManualPowerAlgorithmConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_EnablePowerMatchingPowerAlgorithm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerMatchingPowerAlgorithmConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).EnablePowerMatchingPowerAlgorithm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/EnablePowerMatchingPowerAlgorithm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).EnablePowerMatchingPowerAlgorithm(ctx, req.(*PowerMatchingPowerAlgorithmConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_SetMinerConfigTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerConfigTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).SetMinerConfigTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/SetMinerConfigTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).SetMinerConfigTemplate(ctx, req.(*MinerConfigTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_EnablePowerNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).EnablePowerNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/EnablePowerNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).EnablePowerNode(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_DisablePowerNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).DisablePowerNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/DisablePowerNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).DisablePowerNode(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerNode_GetDeploymentID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerNodeServer).GetDeploymentID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/powernode.PowerNode/GetDeploymentID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerNodeServer).GetDeploymentID(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _PowerNode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "powernode.PowerNode",
	HandlerType: (*PowerNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TriggerCircuitBreaker",
			Handler:    _PowerNode_TriggerCircuitBreaker_Handler,
		},
		{
			MethodName: "GetTransitionList",
			Handler:    _PowerNode_GetTransitionList_Handler,
		},
		{
			MethodName: "ResetStateMachine",
			Handler:    _PowerNode_ResetStateMachine_Handler,
		},
		{
			MethodName: "GetStateMachineStatus",
			Handler:    _PowerNode_GetStateMachineStatus_Handler,
		},
		{
			MethodName: "GetMinerMgrMiners",
			Handler:    _PowerNode_GetMinerMgrMiners_Handler,
		},
		{
			MethodName: "SetNumberOfMiners",
			Handler:    _PowerNode_SetNumberOfMiners_Handler,
		},
		{
			MethodName: "GetCurrentState",
			Handler:    _PowerNode_GetCurrentState_Handler,
		},
		{
			MethodName: "GetMinerStates",
			Handler:    _PowerNode_GetMinerStates_Handler,
		},
		{
			MethodName: "EnableManualPowerAlgorithm",
			Handler:    _PowerNode_EnableManualPowerAlgorithm_Handler,
		},
		{
			MethodName: "EnablePowerMatchingPowerAlgorithm",
			Handler:    _PowerNode_EnablePowerMatchingPowerAlgorithm_Handler,
		},
		{
			MethodName: "SetMinerConfigTemplate",
			Handler:    _PowerNode_SetMinerConfigTemplate_Handler,
		},
		{
			MethodName: "EnablePowerNode",
			Handler:    _PowerNode_EnablePowerNode_Handler,
		},
		{
			MethodName: "DisablePowerNode",
			Handler:    _PowerNode_DisablePowerNode_Handler,
		},
		{
			MethodName: "GetDeploymentID",
			Handler:    _PowerNode_GetDeploymentID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.lakeparime.com/apis/powernode/powernode.proto",
}

func init() {
	proto.RegisterFile("golang.lakeparime.com/apis/powernode/powernode.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1821 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0x5f, 0x6f, 0x1b, 0xb9,
	0x11, 0xbf, 0xb5, 0xe5, 0x3f, 0x1a, 0xcb, 0x8e, 0xcc, 0x8b, 0x1d, 0xd9, 0x17, 0x18, 0xca, 0xa2,
	0xbd, 0x1a, 0x41, 0xa0, 0x5c, 0x13, 0x5f, 0x7a, 0x77, 0x38, 0x04, 0x95, 0x25, 0x59, 0xde, 0x56,
	0x96, 0x05, 0x4a, 0x4e, 0xd0, 0xf6, 0x50, 0x80, 0xd1, 0xd2, 0xf2, 0xde, 0xed, 0x92, 0x2a, 0x97,
	0x72, 0x92, 0x7e, 0x83, 0x02, 0x7d, 0xeb, 0xa7, 0xe8, 0x53, 0x5f, 0xfa, 0x52, 0xa0, 0x9f, 0xa1,
	0x9f, 0xa9, 0x20, 0x97, 0xab, 0xfd, 0xe3, 0x95, 0x92, 0x14, 0x7d, 0x92, 0x66, 0xe6, 0x37, 0xc3,
	0x19, 0xce, 0x70, 0x38, 0x5c, 0x38, 0x99, 0x70, 0x9f, 0xb0, 0x49, 0xc3, 0x27, 0x3f, 0xd1, 0x29,
	0x11, 0x5e, 0x40, 0x1b, 0x63, 0x1e, 0x3c, 0x25, 0x53, 0x2f, 0x7c, 0x3a, 0xe5, 0x6f, 0xa9, 0x60,
	0xdc, 0xa5, 0xc9, 0xbf, 0xc6, 0x54, 0x70, 0xc9, 0x51, 0x79, 0xce, 0x38, 0x6c, 0x18, 0x03, 0x63,
	0xce, 0x04, 0x71, 0xdf, 0x72, 0xee, 0x36, 0x18, 0x95, 0x91, 0x81, 0x31, 0x0f, 0x02, 0xce, 0xcc,
	0x4f, 0xa4, 0x6a, 0xff, 0x67, 0x05, 0x2a, 0x43, 0x49, 0x24, 0x6d, 0xf1, 0x20, 0x20, 0xcc, 0x45,
	0x08, 0x4a, 0x7d, 0x12, 0xd0, 0x9a, 0x55, 0xb7, 0x8e, 0xcb, 0x58, 0xff, 0x47, 0x35, 0xd8, 0xb8,
	0xf0, 0x18, 0x15, 0x4e, 0xbb, 0xb6, 0x52, 0xb7, 0x8e, 0x4b, 0x38, 0x26, 0x13, 0xc9, 0xa0, 0xb6,
	0xaa, 0x15, 0x62, 0x12, 0x1d, 0x01, 0x5c, 0x90, 0x77, 0x78, 0xc6, 0xa4, 0x17, 0xd0, 0x5a, 0xa9,
	0x6e, 0x1d, 0x6f, 0xe3, 0x14, 0x07, 0xd9, 0x50, 0xe9, 0x91, 0x50, 0x76, 0xde, 0xd1, 0xf1, 0x4c,
	0x52, 0xb7, 0xb6, 0xa6, 0x11, 0x19, 0x1e, 0x7a, 0x0c, 0xd5, 0xe8, 0xbf, 0xc7, 0x59, 0x8b, 0xcf,
	0x98, 0xa4, 0xa2, 0xb6, 0xae, 0x71, 0x77, 0xf8, 0xe8, 0x97, 0xb0, 0x71, 0xc9, 0x3a, 0x42, 0x70,
	0x51, 0xdb, 0xa8, 0x5b, 0xc7, 0x5b, 0xcf, 0x1e, 0x34, 0x92, 0x6d, 0x4a, 0x47, 0x88, 0x63, 0x1c,
	0xfa, 0x1a, 0xca, 0x97, 0x6c, 0x38, 0x1b, 0x8f, 0x69, 0x18, 0xd6, 0x36, 0x97, 0x2b, 0x25, 0x48,
	0xf4, 0x10, 0xca, 0x2a, 0x0e, 0x3a, 0xa5, 0x44, 0xd6, 0xca, 0xda, 0x9d, 0x84, 0x61, 0x77, 0xa1,
	0x9a, 0x56, 0xec, 0x79, 0xa1, 0x44, 0xcf, 0x61, 0xd3, 0x90, 0x61, 0xcd, 0xaa, 0xaf, 0x2e, 0x5b,
	0x67, 0x0e, 0xb4, 0x5f, 0xc2, 0xce, 0x48, 0x10, 0x16, 0x7a, 0x2a, 0x4a, 0x6d, 0xe6, 0x09, 0x94,
	0x7a, 0x7c, 0x12, 0x9b, 0xa8, 0xa5, 0x4c, 0xa4, 0x80, 0x7c, 0x82, 0x35, 0xca, 0xfe, 0x9b, 0x05,
	0xdb, 0x19, 0xbe, 0x4a, 0xd6, 0x50, 0x12, 0xa1, 0x76, 0xdb, 0xd2, 0x6e, 0xc7, 0x24, 0x3a, 0x84,
	0xcd, 0x33, 0x8f, 0x79, 0xe1, 0x0d, 0x75, 0x75, 0x86, 0xb7, 0xf1, 0x9c, 0xd6, 0x5a, 0x66, 0x8f,
	0x54, 0x8a, 0x37, 0x71, 0x4c, 0xce, 0x4b, 0xa5, 0x94, 0x2a, 0x95, 0x23, 0x80, 0x79, 0x6a, 0x42,
	0x93, 0xd4, 0x14, 0xc7, 0x3e, 0x98, 0x97, 0x12, 0xda, 0x81, 0x15, 0xa7, 0xad, 0x3d, 0x29, 0xe1,
	0x15, 0xa7, 0x6d, 0xff, 0xcb, 0x82, 0x5d, 0x2d, 0xd3, 0x1b, 0x72, 0x41, 0xc6, 0x37, 0x1e, 0xcb,
	0xd4, 0x9e, 0x95, 0xad, 0xbd, 0x27, 0xb0, 0xdb, 0x9a, 0x09, 0x41, 0x99, 0x4c, 0xc2, 0xd4, 0xde,
	0x97, 0xf1, 0x5d, 0x41, 0x3a, 0xf8, 0xd5, 0x6c, 0xf0, 0x75, 0xd8, 0x52, 0x55, 0x17, 0x4b, 0xa3,
	0x52, 0x4d, 0xb3, 0x12, 0x04, 0x9f, 0x4e, 0xe7, 0xa5, 0x9a, 0x66, 0xd9, 0x67, 0xb0, 0x93, 0xb8,
	0xae, 0x93, 0x75, 0x02, 0xeb, 0x9a, 0x13, 0xa7, 0xeb, 0x61, 0x2a, 0x5d, 0x77, 0xa2, 0xc4, 0x06,
	0x6b, 0x1f, 0x41, 0xa5, 0x4d, 0xa7, 0x3e, 0x7f, 0x1f, 0x50, 0x26, 0x0b, 0xf6, 0xe8, 0x14, 0x2a,
	0x5d, 0x3c, 0x68, 0x61, 0x1a, 0x4e, 0x39, 0x0b, 0x69, 0x3a, 0x39, 0x56, 0x36, 0x39, 0x6a, 0xdf,
	0x68, 0x18, 0x92, 0x09, 0x35, 0x7b, 0x12, 0x93, 0xf6, 0x4b, 0xa8, 0xe8, 0xd5, 0x30, 0xfd, 0xd3,
	0x8c, 0x86, 0x12, 0xed, 0xa7, 0x3c, 0x55, 0x81, 0x19, 0x4a, 0xf3, 0x09, 0x9b, 0x11, 0x5f, 0x1b,
	0xd8, 0xc4, 0x86, 0xb2, 0xff, 0x51, 0x86, 0x8a, 0xd9, 0x5f, 0x1d, 0x03, 0xba, 0x86, 0x46, 0x4c,
	0xcf, 0x82, 0x80, 0xa8, 0xed, 0x6e, 0x53, 0xdf, 0xbb, 0xa5, 0x82, 0xba, 0x23, 0x9e, 0xc4, 0xf3,
	0x9a, 0x48, 0x79, 0xce, 0x67, 0x66, 0x21, 0x0b, 0x7f, 0xa2, 0x16, 0xfa, 0x23, 0x3c, 0x4e, 0xd8,
	0x03, 0xb5, 0x9b, 0x2d, 0xce, 0xc2, 0x59, 0x40, 0x5d, 0x87, 0x0d, 0x48, 0x28, 0xbf, 0x1e, 0xd2,
	0x31, 0x67, 0x6e, 0xa8, 0x34, 0x42, 0xed, 0xb4, 0x85, 0x3f, 0x41, 0x03, 0xfd, 0x08, 0x5f, 0xe5,
	0x3d, 0xc2, 0x74, 0x4c, 0xbd, 0x5b, 0xea, 0x9e, 0x09, 0x1e, 0x68, 0xfd, 0x21, 0x9f, 0x89, 0x31,
	0x4d, 0x22, 0x59, 0xd5, 0xab, 0x7c, 0xb2, 0x1e, 0xfa, 0x3d, 0x1c, 0xa7, 0xf8, 0x5d, 0xca, 0xa8,
	0xd0, 0x8a, 0x45, 0x91, 0x94, 0xf4, 0x1a, 0x1f, 0x8d, 0x47, 0xaf, 0xe0, 0x4b, 0x8d, 0x75, 0x82,
	0x29, 0x17, 0x52, 0xb9, 0xd0, 0x15, 0x5e, 0xe1, 0x1e, 0xad, 0x69, 0xcb, 0x1f, 0x89, 0x46, 0x2f,
	0x60, 0xbf, 0xf3, 0x4e, 0x81, 0x46, 0x5c, 0x41, 0x7a, 0x5e, 0xe0, 0xc9, 0xc8, 0xce, 0xba, 0xb6,
	0xb3, 0x40, 0x8a, 0xbe, 0x82, 0xcf, 0x9b, 0xb7, 0xc4, 0xf3, 0xc9, 0x1b, 0x9f, 0xea, 0xa5, 0x22,
	0xa5, 0x0d, 0xad, 0x54, 0x24, 0x42, 0x3d, 0x78, 0xd4, 0xe2, 0xbe, 0xeb, 0x84, 0x3e, 0x1d, 0xd1,
	0x60, 0x9a, 0x75, 0xa6, 0x45, 0xfd, 0xd0, 0x9b, 0x45, 0x1d, 0xdb, 0xc2, 0x1f, 0x06, 0xa2, 0xdf,
	0x40, 0xfd, 0x9c, 0xcb, 0xe5, 0xc6, 0xca, 0xda, 0xd8, 0x07, 0x71, 0xe8, 0x4b, 0xd8, 0x89, 0x2a,
	0x8a, 0xba, 0xe6, 0xd0, 0x80, 0x3e, 0x34, 0x39, 0x2e, 0x3a, 0x81, 0xbd, 0x0e, 0x53, 0x51, 0xb9,
	0x39, 0xf8, 0x96, 0x86, 0x17, 0x0b, 0xd1, 0x33, 0xb8, 0xdf, 0x1c, 0x4b, 0xef, 0x96, 0xe6, 0x94,
	0x2a, 0x5a, 0xa9, 0x50, 0x86, 0x1a, 0x80, 0x1c, 0xd7, 0xcf, 0x6b, 0x6c, 0x6b, 0x8d, 0x02, 0x09,
	0xfa, 0x1e, 0x0e, 0xae, 0x98, 0xa0, 0x64, 0x7c, 0xa3, 0x3c, 0xc8, 0xa9, 0xed, 0x68, 0xb5, 0xc5,
	0x00, 0xf4, 0x12, 0x0e, 0x47, 0x44, 0x4c, 0xa8, 0x2c, 0xf4, 0xf3, 0x9e, 0x56, 0x5f, 0x82, 0x40,
	0x4d, 0xd8, 0xd1, 0x79, 0x6e, 0xfa, 0x13, 0x2e, 0x3c, 0x79, 0x13, 0xd4, 0xaa, 0x75, 0xeb, 0x78,
	0xe7, 0xd9, 0x41, 0xaa, 0x3d, 0x66, 0x01, 0x38, 0xa7, 0xa0, 0xca, 0x29, 0x5a, 0x20, 0x3a, 0x10,
	0x54, 0x4e, 0xb9, 0xc7, 0x64, 0x6d, 0x57, 0xaf, 0x5d, 0x24, 0xb2, 0xff, 0xbe, 0x02, 0xe5, 0x73,
	0x12, 0xde, 0xbc, 0xe1, 0x44, 0xb8, 0x6a, 0x93, 0x55, 0x7e, 0x87, 0x94, 0x85, 0x5c, 0x84, 0x0e,
	0x8b, 0x4b, 0x40, 0xf5, 0x69, 0x0b, 0x17, 0xca, 0x54, 0x37, 0x7d, 0xc5, 0x7d, 0x19, 0x77, 0x53,
	0x0b, 0xc7, 0xa4, 0x9a, 0x51, 0xce, 0x84, 0xea, 0xa4, 0x6c, 0xfc, 0xde, 0x61, 0xe7, 0x54, 0xc8,
	0x3f, 0x9b, 0xa6, 0x70, 0x87, 0x8f, 0x4e, 0xe1, 0xa1, 0xe3, 0x52, 0xe2, 0x2b, 0x5f, 0x04, 0x91,
	0x54, 0xfd, 0xd2, 0x70, 0xa0, 0x3c, 0x55, 0x45, 0x66, 0x0e, 0xfa, 0x52, 0x0c, 0xea, 0x83, 0x1d,
	0x8b, 0x54, 0x6d, 0x36, 0x6f, 0xa9, 0x20, 0x93, 0x3b, 0x96, 0xa2, 0x83, 0xfd, 0x11, 0x48, 0x73,
	0xc3, 0x44, 0x53, 0x95, 0xba, 0x61, 0xce, 0x60, 0x2b, 0xb9, 0x9e, 0x42, 0xf4, 0xab, 0x0c, 0x69,
	0xee, 0xb2, 0xbd, 0xc2, 0xbb, 0x0c, 0xa7, 0x91, 0xf6, 0x5f, 0xd7, 0x00, 0x12, 0x5a, 0x8d, 0x7b,
	0x6d, 0x7a, 0xeb, 0x8d, 0xa9, 0x22, 0x67, 0xf1, 0x6d, 0x95, 0xe1, 0xa1, 0x9f, 0xc1, 0xf6, 0x15,
	0xf3, 0xde, 0x8d, 0xbc, 0x80, 0x86, 0x92, 0x04, 0x53, 0x33, 0x6c, 0x66, 0x99, 0xe8, 0x25, 0x6c,
	0xab, 0x18, 0x3c, 0x36, 0x31, 0xa6, 0x56, 0x75, 0x01, 0xa5, 0xc7, 0xa1, 0x8c, 0x1c, 0x67, 0xe1,
	0xa8, 0x07, 0xf7, 0xdb, 0x34, 0xf4, 0x04, 0x75, 0xb3, 0x66, 0x4a, 0x1f, 0x30, 0x53, 0xa8, 0xf5,
	0x7f, 0x4f, 0xc7, 0x0b, 0xd8, 0x6f, 0x75, 0xf5, 0xbe, 0x5d, 0x4d, 0xd5, 0x9c, 0xec, 0x30, 0xd3,
	0x80, 0x74, 0x8a, 0xd6, 0xf0, 0x02, 0x29, 0x3a, 0x01, 0x98, 0x57, 0xb8, 0x6a, 0xad, 0x2a, 0x4d,
	0xf7, 0x73, 0xb1, 0x68, 0x21, 0x4e, 0xe1, 0x3e, 0x58, 0x90, 0x9b, 0x1f, 0x51, 0x90, 0x27, 0xb0,
	0x67, 0x62, 0x99, 0xd7, 0x7b, 0x74, 0x0a, 0xa2, 0x96, 0x5a, 0x2c, 0x54, 0x07, 0x6a, 0xc0, 0xb9,
	0x7f, 0x85, 0x7b, 0xba, 0x81, 0x96, 0x71, 0x4c, 0xa2, 0xef, 0xcc, 0x28, 0xe5, 0x0c, 0x9a, 0xae,
	0x2b, 0xd4, 0x64, 0xb3, 0xad, 0x47, 0x73, 0x94, 0x2f, 0x3a, 0x67, 0x80, 0x73, 0xc8, 0xf4, 0xb0,
	0xb8, 0x93, 0x19, 0x16, 0xed, 0x5f, 0xcc, 0x1f, 0x2a, 0x6a, 0x7e, 0x4f, 0x6c, 0x47, 0xcf, 0x9c,
	0x84, 0x61, 0xff, 0x01, 0x3e, 0xd7, 0xc0, 0x16, 0x67, 0xd7, 0xde, 0x64, 0x3e, 0x68, 0x3d, 0x49,
	0x1e, 0x3a, 0xd6, 0x42, 0x77, 0xe6, 0x4b, 0xec, 0xc3, 0xba, 0xa9, 0x2a, 0x33, 0x3a, 0x45, 0x94,
	0xfd, 0x1a, 0x1e, 0x14, 0x18, 0xd7, 0xf3, 0xe2, 0xf7, 0x50, 0x8e, 0xe9, 0xf8, 0x98, 0x1d, 0xe5,
	0x97, 0xc8, 0xaa, 0xe1, 0x44, 0xc1, 0xfe, 0xa7, 0x95, 0x71, 0x5b, 0xf5, 0x30, 0x5f, 0x1d, 0xbb,
	0x06, 0x6c, 0x1a, 0x9f, 0x62, 0xa3, 0x45, 0x7e, 0xcf, 0x31, 0xea, 0xb8, 0xab, 0x3c, 0x44, 0x56,
	0x94, 0xf7, 0xf9, 0xe3, 0x9e, 0x48, 0x71, 0x1a, 0xa9, 0x5e, 0x10, 0xcd, 0x81, 0xd3, 0xf4, 0x7d,
	0xfe, 0xd6, 0x3c, 0x13, 0xe6, 0xb4, 0xca, 0x4a, 0x73, 0xe0, 0x0c, 0xb8, 0x90, 0x66, 0xb8, 0x8e,
	0x49, 0x9b, 0x01, 0x24, 0x46, 0xd2, 0x35, 0x61, 0x65, 0x6b, 0xc2, 0x86, 0x8a, 0xfe, 0x1b, 0x52,
	0xc1, 0xd4, 0x8b, 0x23, 0x9a, 0x68, 0x33, 0xbc, 0x18, 0x33, 0x20, 0x61, 0xf8, 0x96, 0x0b, 0xd7,
	0xbc, 0x47, 0x33, 0x3c, 0xfb, 0x2f, 0x16, 0x3c, 0xd2, 0x57, 0xc3, 0x05, 0x91, 0x6a, 0xf0, 0x9e,
	0x64, 0xaf, 0x16, 0xe3, 0x87, 0x0d, 0x95, 0x21, 0xb9, 0x96, 0xf4, 0xfd, 0x05, 0x11, 0x13, 0x8f,
	0x99, 0x69, 0x35, 0xc3, 0x43, 0xbf, 0x86, 0x2f, 0x30, 0x25, 0x63, 0x3d, 0xb5, 0x7a, 0xd7, 0xd7,
	0x54, 0x50, 0x36, 0xa6, 0xa3, 0x1b, 0x41, 0xc3, 0x1b, 0xee, 0xbb, 0xe6, 0x92, 0x58, 0x06, 0xb1,
	0x7b, 0x70, 0x18, 0x0d, 0xd4, 0x85, 0x3e, 0x34, 0x00, 0x65, 0xee, 0xb0, 0x68, 0x64, 0x8a, 0x3c,
	0x29, 0x90, 0x3c, 0xfe, 0x36, 0x7f, 0xaf, 0xa2, 0x6d, 0x28, 0x5f, 0xf5, 0xdb, 0x9d, 0x33, 0xa7,
	0xdf, 0x69, 0x57, 0x3f, 0x43, 0x15, 0xd8, 0xbc, 0x68, 0x8e, 0x5a, 0xe7, 0x4e, 0xbf, 0x5b, 0xb5,
	0x10, 0xc0, 0xfa, 0x45, 0xb3, 0x7f, 0xd5, 0xec, 0x55, 0x57, 0x1e, 0xff, 0x2e, 0xd7, 0x50, 0xd1,
	0x16, 0x6c, 0x5c, 0xf5, 0x7f, 0xdb, 0xbf, 0x7c, 0xdd, 0xaf, 0x7e, 0xa6, 0x90, 0xcd, 0xd6, 0xc8,
	0x79, 0xd5, 0xa9, 0x5a, 0x68, 0x13, 0x4a, 0x4e, 0xbb, 0xd7, 0xa9, 0xae, 0x28, 0x6b, 0xc3, 0x51,
	0x13, 0x8f, 0x94, 0xb5, 0x55, 0x54, 0x86, 0xb5, 0x0e, 0xc6, 0x97, 0xb8, 0x5a, 0x8a, 0x04, 0x97,
	0x83, 0x81, 0x12, 0xac, 0x3d, 0xfb, 0xf7, 0x06, 0x94, 0xb5, 0x5b, 0x7d, 0xee, 0x52, 0xf4, 0x1c,
	0xf6, 0x46, 0xc2, 0x9b, 0x4c, 0xa8, 0x68, 0x79, 0x62, 0x3c, 0xf3, 0xe4, 0xa9, 0xa0, 0xe4, 0x27,
	0x2a, 0x50, 0xa5, 0x61, 0xbe, 0x49, 0xbc, 0xe2, 0x9e, 0x7b, 0x98, 0xa1, 0xd0, 0x29, 0xec, 0x76,
	0xa9, 0xcc, 0xbd, 0x84, 0xef, 0x16, 0x71, 0xfb, 0xf0, 0xa0, 0xf8, 0x3d, 0xac, 0xe0, 0x4f, 0x61,
	0x17, 0xd3, 0x90, 0xca, 0xcc, 0xc3, 0x72, 0xf9, 0xa2, 0x7b, 0xdd, 0x2c, 0xdc, 0x6c, 0x4d, 0x56,
	0xe9, 0x8b, 0x05, 0xaf, 0x78, 0x73, 0xa0, 0x95, 0xe3, 0xda, 0xbb, 0x8b, 0x89, 0x30, 0xe3, 0x4f,
	0x56, 0xff, 0xa0, 0xf0, 0x1e, 0xd5, 0xda, 0xdf, 0xc1, 0xee, 0x90, 0xca, 0xfe, 0x2c, 0x78, 0x43,
	0xc5, 0xe5, 0xb5, 0xd1, 0x7e, 0x90, 0xc7, 0x9b, 0x27, 0x5c, 0xce, 0xfb, 0x6f, 0xe0, 0x5e, 0x97,
	0xca, 0xcc, 0x13, 0x2d, 0xbb, 0x6e, 0xda, 0x4e, 0x06, 0xf6, 0x02, 0x76, 0x62, 0x9f, 0xcd, 0xfd,
	0x9f, 0x55, 0xdc, 0x2f, 0x74, 0x38, 0x44, 0x3f, 0xc0, 0x61, 0x34, 0xd0, 0x16, 0x55, 0x34, 0xfa,
	0x79, 0x5a, 0x6b, 0x61, 0xc9, 0x67, 0xbc, 0xca, 0x3c, 0x72, 0x7f, 0x84, 0x47, 0x91, 0xf5, 0x25,
	0x47, 0x17, 0x3d, 0xc9, 0x0f, 0x90, 0xcb, 0x8e, 0xf8, 0xe2, 0xb5, 0x7e, 0x80, 0xfd, 0xa1, 0xd9,
	0x81, 0x5c, 0x2b, 0x5d, 0xd0, 0x8d, 0x63, 0xf9, 0xa1, 0xbd, 0xbc, 0x5b, 0xeb, 0xac, 0x7e, 0x03,
	0xf7, 0x52, 0x91, 0xe8, 0x43, 0xb1, 0x38, 0x33, 0x19, 0xbf, 0xbe, 0x85, 0x6a, 0xdb, 0x0b, 0xff,
	0x27, 0xd5, 0xa8, 0x1c, 0x32, 0x9f, 0x15, 0x16, 0x6b, 0xa6, 0x61, 0xa7, 0x75, 0x38, 0xf2, 0xd8,
	0x35, 0x4f, 0x7f, 0x8d, 0x24, 0x53, 0x2f, 0x4c, 0xe0, 0x6f, 0xd6, 0xf5, 0x57, 0xc4, 0xe7, 0xff,
	0x0d, 0x00, 0x00, 0xff, 0xff, 0xc7, 0x75, 0x60, 0x3a, 0xb8, 0x14, 0x00, 0x00,
}
