// Code generated by protoc-gen-go.
// source: golang.lakeparime.info/apis/antminerdataservice/antminerdataservice.proto
// DO NOT EDIT!

/*
Package antminerdataservice is a generated protocol buffer package.

It is generated from these files:
	golang.lakeparime.info/apis/antminerdataservice/antminerdataservice.proto

It has these top-level messages:
	PingResponse
	AddMinerRequest
	MinerGroup
	Miner
	HashboardHashrate
	MinerPoolHashrate
	MinerTemperature
	MinerState
	MinerVoltage
	MinerGroups
	MinerVoltages
	MinerStates
	HashboardHashrates
	MinerPoolHashrates
	MinerTemperatures
	Miners
*/
package antminerdataservice

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import stdprotos "golang.lakeparime.info/apis/stdprotos"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HashingStatus int32

const (
	HashingStatus_UNKNOWNHASHINGSTATUS HashingStatus = 0
	HashingStatus_ACTIVE               HashingStatus = 1
	HashingStatus_IDLE                 HashingStatus = 2
	HashingStatus_STARTING             HashingStatus = 3
	HashingStatus_ERROR                HashingStatus = 4
	HashingStatus_STOPPING             HashingStatus = 5
)

var HashingStatus_name = map[int32]string{
	0: "UNKNOWNHASHINGSTATUS",
	1: "ACTIVE",
	2: "IDLE",
	3: "STARTING",
	4: "ERROR",
	5: "STOPPING",
}
var HashingStatus_value = map[string]int32{
	"UNKNOWNHASHINGSTATUS": 0,
	"ACTIVE":               1,
	"IDLE":                 2,
	"STARTING":             3,
	"ERROR":                4,
	"STOPPING":             5,
}

func (x HashingStatus) String() string {
	return proto.EnumName(HashingStatus_name, int32(x))
}
func (HashingStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type MinerType int32

const (
	MinerType_CGMINERCLIENT MinerType = 0
	MinerType_S9            MinerType = 1
	MinerType_S17           MinerType = 2
	MinerType_S19           MinerType = 3
)

var MinerType_name = map[int32]string{
	0: "CGMINERCLIENT",
	1: "S9",
	2: "S17",
	3: "S19",
}
var MinerType_value = map[string]int32{
	"CGMINERCLIENT": 0,
	"S9":            1,
	"S17":           2,
	"S19":           3,
}

func (x MinerType) String() string {
	return proto.EnumName(MinerType_name, int32(x))
}
func (MinerType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// comment: message pingresponse
type PingResponse struct {
	// comment: field pingresponse.response
	Response string `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PingResponse) GetResponse() string {
	if m != nil {
		return m.Response
	}
	return ""
}

type AddMinerRequest struct {
	Miner *Miner `protobuf:"bytes,1,opt,name=Miner" json:"Miner,omitempty"`
}

func (m *AddMinerRequest) Reset()                    { *m = AddMinerRequest{} }
func (m *AddMinerRequest) String() string            { return proto.CompactTextString(m) }
func (*AddMinerRequest) ProtoMessage()               {}
func (*AddMinerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AddMinerRequest) GetMiner() *Miner {
	if m != nil {
		return m.Miner
	}
	return nil
}

type MinerGroup struct {
	// link miner group to deployment ID
	DeploymentID uint64 `protobuf:"varint,1,opt,name=DeploymentID" json:"DeploymentID,omitempty"`
	// Display Friendly name
	Name string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	// Display Friendly description
	Description string `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
	// The date the group was created
	DeployedUnixTimestamp uint64 `protobuf:"varint,4,opt,name=DeployedUnixTimestamp" json:"DeployedUnixTimestamp,omitempty"`
	// Required by the mkdb - will be ignored for add requests
	ID uint64 `protobuf:"varint,5,opt,name=ID" json:"ID,omitempty"`
	// The timestamp of when the record was recorded in the service - will be ignored for add requests
	DBUnixTimestamp uint64 `protobuf:"varint,6,opt,name=DBUnixTimestamp" json:"DBUnixTimestamp,omitempty"`
}

func (m *MinerGroup) Reset()                    { *m = MinerGroup{} }
func (m *MinerGroup) String() string            { return proto.CompactTextString(m) }
func (*MinerGroup) ProtoMessage()               {}
func (*MinerGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MinerGroup) GetDeploymentID() uint64 {
	if m != nil {
		return m.DeploymentID
	}
	return 0
}

func (m *MinerGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MinerGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MinerGroup) GetDeployedUnixTimestamp() uint64 {
	if m != nil {
		return m.DeployedUnixTimestamp
	}
	return 0
}

func (m *MinerGroup) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MinerGroup) GetDBUnixTimestamp() uint64 {
	if m != nil {
		return m.DBUnixTimestamp
	}
	return 0
}

type Miner struct {
	// Linked to the Miner group table/message
	MinerGroupID *MinerGroup `protobuf:"bytes,1,opt,name=MinerGroupID" json:"MinerGroupID,omitempty"`
	// Specifies which type of miner it is
	MinerType MinerType `protobuf:"varint,2,opt,name=MinerType,enum=antminerdataservice.MinerType" json:"MinerType,omitempty"`
	// Display Friendly name for the Miner
	MinerName string `protobuf:"bytes,3,opt,name=MinerName" json:"MinerName,omitempty"`
	// Display Friendly description for the Miner
	MinerDescription string `protobuf:"bytes,4,opt,name=MinerDescription" json:"MinerDescription,omitempty"`
	// The date the miner was deployed
	DeployedUnixTimestamp uint64 `protobuf:"varint,5,opt,name=DeployedUnixTimestamp" json:"DeployedUnixTimestamp,omitempty"`
	// Required by the mkdb - will be ignored for add requests
	ID uint64 `protobuf:"varint,6,opt,name=ID" json:"ID,omitempty"`
	// The timestamp of when the record was recorded in the service - will be ignored for add requests
	DBUnixTimestamp    uint64 `protobuf:"varint,7,opt,name=DBUnixTimestamp" json:"DBUnixTimestamp,omitempty"`
	IP4                string `protobuf:"bytes,8,opt,name=IP4" json:"IP4,omitempty"`
	CurrentMac         string `protobuf:"bytes,9,opt,name=CurrentMac" json:"CurrentMac,omitempty"`
	SSHPrivateKey      []byte `protobuf:"bytes,10,opt,name=SSHPrivateKey,proto3" json:"SSHPrivateKey,omitempty"`
	ManagedByPowernode bool   `protobuf:"varint,11,opt,name=ManagedByPowernode" json:"ManagedByPowernode,omitempty"`
}

func (m *Miner) Reset()                    { *m = Miner{} }
func (m *Miner) String() string            { return proto.CompactTextString(m) }
func (*Miner) ProtoMessage()               {}
func (*Miner) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Miner) GetMinerGroupID() *MinerGroup {
	if m != nil {
		return m.MinerGroupID
	}
	return nil
}

func (m *Miner) GetMinerType() MinerType {
	if m != nil {
		return m.MinerType
	}
	return MinerType_CGMINERCLIENT
}

func (m *Miner) GetMinerName() string {
	if m != nil {
		return m.MinerName
	}
	return ""
}

func (m *Miner) GetMinerDescription() string {
	if m != nil {
		return m.MinerDescription
	}
	return ""
}

func (m *Miner) GetDeployedUnixTimestamp() uint64 {
	if m != nil {
		return m.DeployedUnixTimestamp
	}
	return 0
}

func (m *Miner) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Miner) GetDBUnixTimestamp() uint64 {
	if m != nil {
		return m.DBUnixTimestamp
	}
	return 0
}

func (m *Miner) GetIP4() string {
	if m != nil {
		return m.IP4
	}
	return ""
}

func (m *Miner) GetCurrentMac() string {
	if m != nil {
		return m.CurrentMac
	}
	return ""
}

func (m *Miner) GetSSHPrivateKey() []byte {
	if m != nil {
		return m.SSHPrivateKey
	}
	return nil
}

func (m *Miner) GetManagedByPowernode() bool {
	if m != nil {
		return m.ManagedByPowernode
	}
	return false
}

type HashboardHashrate struct {
	// Linked to the Miner table/message
	MinerID uint64 `protobuf:"varint,1,opt,name=MinerID" json:"MinerID,omitempty"`
	// the hashboard position index, some miners have 3 hashboards, some have 1
	HashboardPosition uint32 `protobuf:"varint,2,opt,name=HashboardPosition" json:"HashboardPosition,omitempty"`
	// The hashrate of this board in hashes
	Hashrate5SecAverageInHashesPerSecond float64 `protobuf:"fixed64,3,opt,name=Hashrate5SecAverageInHashesPerSecond" json:"Hashrate5SecAverageInHashesPerSecond,omitempty"`
	// The timestamp when this hashrate was read
	ReadingUnixTimestamp uint64 `protobuf:"varint,4,opt,name=ReadingUnixTimestamp" json:"ReadingUnixTimestamp,omitempty"`
	// Required by the mkdb - will be ignored for add requests
	ID uint64 `protobuf:"varint,6,opt,name=ID" json:"ID,omitempty"`
	// The timestamp of when the record was recorded in the service - will be ignored for add requests
	DBUnixTimestamp uint64 `protobuf:"varint,7,opt,name=DBUnixTimestamp" json:"DBUnixTimestamp,omitempty"`
}

func (m *HashboardHashrate) Reset()                    { *m = HashboardHashrate{} }
func (m *HashboardHashrate) String() string            { return proto.CompactTextString(m) }
func (*HashboardHashrate) ProtoMessage()               {}
func (*HashboardHashrate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *HashboardHashrate) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

func (m *HashboardHashrate) GetHashboardPosition() uint32 {
	if m != nil {
		return m.HashboardPosition
	}
	return 0
}

func (m *HashboardHashrate) GetHashrate5SecAverageInHashesPerSecond() float64 {
	if m != nil {
		return m.Hashrate5SecAverageInHashesPerSecond
	}
	return 0
}

func (m *HashboardHashrate) GetReadingUnixTimestamp() uint64 {
	if m != nil {
		return m.ReadingUnixTimestamp
	}
	return 0
}

func (m *HashboardHashrate) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *HashboardHashrate) GetDBUnixTimestamp() uint64 {
	if m != nil {
		return m.DBUnixTimestamp
	}
	return 0
}

type MinerPoolHashrate struct {
	// Linked to the Miner table/message
	MinerID uint64 `protobuf:"varint,1,opt,name=MinerID" json:"MinerID,omitempty"`
	// The hashrate of this board in GH/s
	Hashrate5SecAverageInHashesPerSecond float64 `protobuf:"fixed64,2,opt,name=Hashrate5SecAverageInHashesPerSecond" json:"Hashrate5SecAverageInHashesPerSecond,omitempty"`
	// The timestamp when this hashrate was read
	ReadingUnixTimestamp uint64 `protobuf:"varint,3,opt,name=ReadingUnixTimestamp" json:"ReadingUnixTimestamp,omitempty"`
	// Required by the mkdb - will be ignored for add requests
	ID uint64 `protobuf:"varint,4,opt,name=ID" json:"ID,omitempty"`
	// The timestamp of when the record was recorded in the service - will be ignored for add requests
	DBUnixTimestamp uint64 `protobuf:"varint,5,opt,name=DBUnixTimestamp" json:"DBUnixTimestamp,omitempty"`
}

func (m *MinerPoolHashrate) Reset()                    { *m = MinerPoolHashrate{} }
func (m *MinerPoolHashrate) String() string            { return proto.CompactTextString(m) }
func (*MinerPoolHashrate) ProtoMessage()               {}
func (*MinerPoolHashrate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *MinerPoolHashrate) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

func (m *MinerPoolHashrate) GetHashrate5SecAverageInHashesPerSecond() float64 {
	if m != nil {
		return m.Hashrate5SecAverageInHashesPerSecond
	}
	return 0
}

func (m *MinerPoolHashrate) GetReadingUnixTimestamp() uint64 {
	if m != nil {
		return m.ReadingUnixTimestamp
	}
	return 0
}

func (m *MinerPoolHashrate) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MinerPoolHashrate) GetDBUnixTimestamp() uint64 {
	if m != nil {
		return m.DBUnixTimestamp
	}
	return 0
}

type MinerTemperature struct {
	// Linked to the Miner table/message
	MinerID uint64 `protobuf:"varint,1,opt,name=MinerID" json:"MinerID,omitempty"`
	// The list of temp sensor readings on a miner
	TemperatureInCelsius []float64 `protobuf:"fixed64,2,rep,packed,name=TemperatureInCelsius" json:"TemperatureInCelsius,omitempty"`
	// The timestamp when this hashrate was read
	ReadingUnixTimestamp uint64 `protobuf:"varint,3,opt,name=ReadingUnixTimestamp" json:"ReadingUnixTimestamp,omitempty"`
	// Required by the mkdb - will be ignored for add requests
	ID uint64 `protobuf:"varint,4,opt,name=ID" json:"ID,omitempty"`
	// The timestamp of when the record was recorded in the service - will be ignored for add requests
	DBUnixTimestamp uint64 `protobuf:"varint,5,opt,name=DBUnixTimestamp" json:"DBUnixTimestamp,omitempty"`
}

func (m *MinerTemperature) Reset()                    { *m = MinerTemperature{} }
func (m *MinerTemperature) String() string            { return proto.CompactTextString(m) }
func (*MinerTemperature) ProtoMessage()               {}
func (*MinerTemperature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MinerTemperature) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

func (m *MinerTemperature) GetTemperatureInCelsius() []float64 {
	if m != nil {
		return m.TemperatureInCelsius
	}
	return nil
}

func (m *MinerTemperature) GetReadingUnixTimestamp() uint64 {
	if m != nil {
		return m.ReadingUnixTimestamp
	}
	return 0
}

func (m *MinerTemperature) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MinerTemperature) GetDBUnixTimestamp() uint64 {
	if m != nil {
		return m.DBUnixTimestamp
	}
	return 0
}

type MinerState struct {
	// Linked to the Miner table/message
	MinerID uint64 `protobuf:"varint,1,opt,name=MinerID" json:"MinerID,omitempty"`
	// The new state the miner was set to
	HashingStatus HashingStatus `protobuf:"varint,2,opt,name=HashingStatus,enum=antminerdataservice.HashingStatus" json:"HashingStatus,omitempty"`
	// The timestamp when this hashrate was read
	ReadingUnixTimestamp uint64 `protobuf:"varint,3,opt,name=ReadingUnixTimestamp" json:"ReadingUnixTimestamp,omitempty"`
	// Required by the mkdb - will be ignored for add requests
	ID uint64 `protobuf:"varint,4,opt,name=ID" json:"ID,omitempty"`
	// The timestamp of when the record was recorded in the service - will be ignored for add requests
	DBUnixTimestamp uint64 `protobuf:"varint,5,opt,name=DBUnixTimestamp" json:"DBUnixTimestamp,omitempty"`
}

func (m *MinerState) Reset()                    { *m = MinerState{} }
func (m *MinerState) String() string            { return proto.CompactTextString(m) }
func (*MinerState) ProtoMessage()               {}
func (*MinerState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *MinerState) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

func (m *MinerState) GetHashingStatus() HashingStatus {
	if m != nil {
		return m.HashingStatus
	}
	return HashingStatus_UNKNOWNHASHINGSTATUS
}

func (m *MinerState) GetReadingUnixTimestamp() uint64 {
	if m != nil {
		return m.ReadingUnixTimestamp
	}
	return 0
}

func (m *MinerState) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MinerState) GetDBUnixTimestamp() uint64 {
	if m != nil {
		return m.DBUnixTimestamp
	}
	return 0
}

type MinerVoltage struct {
	// Linked to the Miner table/message
	MinerID uint64 `protobuf:"varint,1,opt,name=MinerID" json:"MinerID,omitempty"`
	// The new voltage set for a miner
	// repeated because some miners can tune individual hashboards
	MinerVoltage []float64 `protobuf:"fixed64,2,rep,packed,name=MinerVoltage" json:"MinerVoltage,omitempty"`
	// The timestamp when this hashrate was read
	ReadingUnixTimestamp uint64 `protobuf:"varint,3,opt,name=ReadingUnixTimestamp" json:"ReadingUnixTimestamp,omitempty"`
	// Required by the mkdb - will be ignored for add requests
	ID uint64 `protobuf:"varint,4,opt,name=ID" json:"ID,omitempty"`
	// The timestamp of when the record was recorded in the service - will be ignored for add requests
	DBUnixTimestamp uint64 `protobuf:"varint,5,opt,name=DBUnixTimestamp" json:"DBUnixTimestamp,omitempty"`
}

func (m *MinerVoltage) Reset()                    { *m = MinerVoltage{} }
func (m *MinerVoltage) String() string            { return proto.CompactTextString(m) }
func (*MinerVoltage) ProtoMessage()               {}
func (*MinerVoltage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *MinerVoltage) GetMinerID() uint64 {
	if m != nil {
		return m.MinerID
	}
	return 0
}

func (m *MinerVoltage) GetMinerVoltage() []float64 {
	if m != nil {
		return m.MinerVoltage
	}
	return nil
}

func (m *MinerVoltage) GetReadingUnixTimestamp() uint64 {
	if m != nil {
		return m.ReadingUnixTimestamp
	}
	return 0
}

func (m *MinerVoltage) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MinerVoltage) GetDBUnixTimestamp() uint64 {
	if m != nil {
		return m.DBUnixTimestamp
	}
	return 0
}

type MinerGroups struct {
	MinerGroups []*MinerGroup `protobuf:"bytes,1,rep,name=MinerGroups" json:"MinerGroups,omitempty"`
}

func (m *MinerGroups) Reset()                    { *m = MinerGroups{} }
func (m *MinerGroups) String() string            { return proto.CompactTextString(m) }
func (*MinerGroups) ProtoMessage()               {}
func (*MinerGroups) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *MinerGroups) GetMinerGroups() []*MinerGroup {
	if m != nil {
		return m.MinerGroups
	}
	return nil
}

type MinerVoltages struct {
	MinerVoltages []*MinerVoltage `protobuf:"bytes,1,rep,name=MinerVoltages" json:"MinerVoltages,omitempty"`
}

func (m *MinerVoltages) Reset()                    { *m = MinerVoltages{} }
func (m *MinerVoltages) String() string            { return proto.CompactTextString(m) }
func (*MinerVoltages) ProtoMessage()               {}
func (*MinerVoltages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MinerVoltages) GetMinerVoltages() []*MinerVoltage {
	if m != nil {
		return m.MinerVoltages
	}
	return nil
}

type MinerStates struct {
	MinerStates []*MinerState `protobuf:"bytes,1,rep,name=MinerStates" json:"MinerStates,omitempty"`
}

func (m *MinerStates) Reset()                    { *m = MinerStates{} }
func (m *MinerStates) String() string            { return proto.CompactTextString(m) }
func (*MinerStates) ProtoMessage()               {}
func (*MinerStates) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *MinerStates) GetMinerStates() []*MinerState {
	if m != nil {
		return m.MinerStates
	}
	return nil
}

type HashboardHashrates struct {
	HashboardHashrates []*HashboardHashrate `protobuf:"bytes,1,rep,name=HashboardHashrates" json:"HashboardHashrates,omitempty"`
}

func (m *HashboardHashrates) Reset()                    { *m = HashboardHashrates{} }
func (m *HashboardHashrates) String() string            { return proto.CompactTextString(m) }
func (*HashboardHashrates) ProtoMessage()               {}
func (*HashboardHashrates) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *HashboardHashrates) GetHashboardHashrates() []*HashboardHashrate {
	if m != nil {
		return m.HashboardHashrates
	}
	return nil
}

type MinerPoolHashrates struct {
	MinerPoolHashrates []*MinerPoolHashrate `protobuf:"bytes,1,rep,name=MinerPoolHashrates" json:"MinerPoolHashrates,omitempty"`
}

func (m *MinerPoolHashrates) Reset()                    { *m = MinerPoolHashrates{} }
func (m *MinerPoolHashrates) String() string            { return proto.CompactTextString(m) }
func (*MinerPoolHashrates) ProtoMessage()               {}
func (*MinerPoolHashrates) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *MinerPoolHashrates) GetMinerPoolHashrates() []*MinerPoolHashrate {
	if m != nil {
		return m.MinerPoolHashrates
	}
	return nil
}

type MinerTemperatures struct {
	MinerTemperatures []*MinerTemperature `protobuf:"bytes,1,rep,name=MinerTemperatures" json:"MinerTemperatures,omitempty"`
}

func (m *MinerTemperatures) Reset()                    { *m = MinerTemperatures{} }
func (m *MinerTemperatures) String() string            { return proto.CompactTextString(m) }
func (*MinerTemperatures) ProtoMessage()               {}
func (*MinerTemperatures) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MinerTemperatures) GetMinerTemperatures() []*MinerTemperature {
	if m != nil {
		return m.MinerTemperatures
	}
	return nil
}

type Miners struct {
	Miners []*Miner `protobuf:"bytes,1,rep,name=Miners" json:"Miners,omitempty"`
}

func (m *Miners) Reset()                    { *m = Miners{} }
func (m *Miners) String() string            { return proto.CompactTextString(m) }
func (*Miners) ProtoMessage()               {}
func (*Miners) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Miners) GetMiners() []*Miner {
	if m != nil {
		return m.Miners
	}
	return nil
}

func init() {
	proto.RegisterType((*PingResponse)(nil), "antminerdataservice.PingResponse")
	proto.RegisterType((*AddMinerRequest)(nil), "antminerdataservice.AddMinerRequest")
	proto.RegisterType((*MinerGroup)(nil), "antminerdataservice.MinerGroup")
	proto.RegisterType((*Miner)(nil), "antminerdataservice.Miner")
	proto.RegisterType((*HashboardHashrate)(nil), "antminerdataservice.HashboardHashrate")
	proto.RegisterType((*MinerPoolHashrate)(nil), "antminerdataservice.MinerPoolHashrate")
	proto.RegisterType((*MinerTemperature)(nil), "antminerdataservice.MinerTemperature")
	proto.RegisterType((*MinerState)(nil), "antminerdataservice.MinerState")
	proto.RegisterType((*MinerVoltage)(nil), "antminerdataservice.MinerVoltage")
	proto.RegisterType((*MinerGroups)(nil), "antminerdataservice.MinerGroups")
	proto.RegisterType((*MinerVoltages)(nil), "antminerdataservice.MinerVoltages")
	proto.RegisterType((*MinerStates)(nil), "antminerdataservice.MinerStates")
	proto.RegisterType((*HashboardHashrates)(nil), "antminerdataservice.HashboardHashrates")
	proto.RegisterType((*MinerPoolHashrates)(nil), "antminerdataservice.MinerPoolHashrates")
	proto.RegisterType((*MinerTemperatures)(nil), "antminerdataservice.MinerTemperatures")
	proto.RegisterType((*Miners)(nil), "antminerdataservice.Miners")
	proto.RegisterEnum("antminerdataservice.HashingStatus", HashingStatus_name, HashingStatus_value)
	proto.RegisterEnum("antminerdataservice.MinerType", MinerType_name, MinerType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AntminerData service

type AntminerDataClient interface {
	AddMiner(ctx context.Context, in *AddMinerRequest, opts ...grpc.CallOption) (*Miner, error)
	// Returns all miner groups in a deployment
	GetMinerGroupsByDeploymentID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*MinerGroups, error)
	// Returns all miners in a deployment which powernode needs to manage
	GetManagedMinersByDeploymentID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*Miners, error)
	// Returns all miners in a deployment
	GetAllMinersByDeploymentID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*Miners, error)
	// Returns all miners in a miner group
	GetAllMinersByMinerGroupID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*Miners, error)
	// Returns a list of hashboard hashrates for a miner ID when provided a miner id and a time range
	GetMinerHashrates(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*HashboardHashrates, error)
	// returns a list of hashrate readings recorded from the pool when provided a miner id and a time range
	GetMinerPoolHashrates(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerPoolHashrates, error)
	// returns a list of temp values in celsius for a miner when provided with a miner id and a time range
	GetMinerTemperatures(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerTemperatures, error)
	// returns the list of miner voltage changes when provided a miner id and a time tange
	GetMinerVoltages(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerVoltages, error)
	// returns the list of miner state changes when provided with a miner ID and a timerange
	GetMinerStates(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerStates, error)
	// Adds a new miner group the datastore
	AddMinerGroupToDeployment(ctx context.Context, in *MinerGroup, opts ...grpc.CallOption) (*common.Void, error)
	// Adds a miner to a miner group
	AddMinerToMinerGroup(ctx context.Context, in *Miner, opts ...grpc.CallOption) (*common.Void, error)
	// Adds a collection of Hashboard hashrate readings to a miner
	AddMinerHashboardReadings(ctx context.Context, in *HashboardHashrates, opts ...grpc.CallOption) (*common.Void, error)
	// Adds a miner pool hashrate reading
	AddMinerPoolHashrateReading(ctx context.Context, in *MinerPoolHashrate, opts ...grpc.CallOption) (*common.Void, error)
	// Adds a temp reading to a miner
	AddMinerTemperatureReading(ctx context.Context, in *MinerTemperature, opts ...grpc.CallOption) (*common.Void, error)
	// Adds a voltage reading to the miner
	AddMinerVoltageReading(ctx context.Context, in *MinerVoltage, opts ...grpc.CallOption) (*common.Void, error)
	// Adds a miner state change to the miner
	AddMinerStateChange(ctx context.Context, in *MinerState, opts ...grpc.CallOption) (*common.Void, error)
}

type antminerDataClient struct {
	cc *grpc.ClientConn
}

func NewAntminerDataClient(cc *grpc.ClientConn) AntminerDataClient {
	return &antminerDataClient{cc}
}

func (c *antminerDataClient) AddMiner(ctx context.Context, in *AddMinerRequest, opts ...grpc.CallOption) (*Miner, error) {
	out := new(Miner)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMiner", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetMinerGroupsByDeploymentID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*MinerGroups, error) {
	out := new(MinerGroups)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetMinerGroupsByDeploymentID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetManagedMinersByDeploymentID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*Miners, error) {
	out := new(Miners)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetManagedMinersByDeploymentID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetAllMinersByDeploymentID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*Miners, error) {
	out := new(Miners)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetAllMinersByDeploymentID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetAllMinersByMinerGroupID(ctx context.Context, in *stdprotos.UniqueID, opts ...grpc.CallOption) (*Miners, error) {
	out := new(Miners)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetAllMinersByMinerGroupID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetMinerHashrates(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*HashboardHashrates, error) {
	out := new(HashboardHashrates)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetMinerHashrates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetMinerPoolHashrates(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerPoolHashrates, error) {
	out := new(MinerPoolHashrates)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetMinerPoolHashrates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetMinerTemperatures(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerTemperatures, error) {
	out := new(MinerTemperatures)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetMinerTemperatures", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetMinerVoltages(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerVoltages, error) {
	out := new(MinerVoltages)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetMinerVoltages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) GetMinerStates(ctx context.Context, in *stdprotos.TimeRangeWithUniqueID, opts ...grpc.CallOption) (*MinerStates, error) {
	out := new(MinerStates)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/GetMinerStates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) AddMinerGroupToDeployment(ctx context.Context, in *MinerGroup, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMinerGroupToDeployment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) AddMinerToMinerGroup(ctx context.Context, in *Miner, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMinerToMinerGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) AddMinerHashboardReadings(ctx context.Context, in *HashboardHashrates, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMinerHashboardReadings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) AddMinerPoolHashrateReading(ctx context.Context, in *MinerPoolHashrate, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMinerPoolHashrateReading", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) AddMinerTemperatureReading(ctx context.Context, in *MinerTemperature, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMinerTemperatureReading", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) AddMinerVoltageReading(ctx context.Context, in *MinerVoltage, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMinerVoltageReading", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *antminerDataClient) AddMinerStateChange(ctx context.Context, in *MinerState, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/antminerdataservice.AntminerData/AddMinerStateChange", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AntminerData service

type AntminerDataServer interface {
	AddMiner(context.Context, *AddMinerRequest) (*Miner, error)
	// Returns all miner groups in a deployment
	GetMinerGroupsByDeploymentID(context.Context, *stdprotos.UniqueID) (*MinerGroups, error)
	// Returns all miners in a deployment which powernode needs to manage
	GetManagedMinersByDeploymentID(context.Context, *stdprotos.UniqueID) (*Miners, error)
	// Returns all miners in a deployment
	GetAllMinersByDeploymentID(context.Context, *stdprotos.UniqueID) (*Miners, error)
	// Returns all miners in a miner group
	GetAllMinersByMinerGroupID(context.Context, *stdprotos.UniqueID) (*Miners, error)
	// Returns a list of hashboard hashrates for a miner ID when provided a miner id and a time range
	GetMinerHashrates(context.Context, *stdprotos.TimeRangeWithUniqueID) (*HashboardHashrates, error)
	// returns a list of hashrate readings recorded from the pool when provided a miner id and a time range
	GetMinerPoolHashrates(context.Context, *stdprotos.TimeRangeWithUniqueID) (*MinerPoolHashrates, error)
	// returns a list of temp values in celsius for a miner when provided with a miner id and a time range
	GetMinerTemperatures(context.Context, *stdprotos.TimeRangeWithUniqueID) (*MinerTemperatures, error)
	// returns the list of miner voltage changes when provided a miner id and a time tange
	GetMinerVoltages(context.Context, *stdprotos.TimeRangeWithUniqueID) (*MinerVoltages, error)
	// returns the list of miner state changes when provided with a miner ID and a timerange
	GetMinerStates(context.Context, *stdprotos.TimeRangeWithUniqueID) (*MinerStates, error)
	// Adds a new miner group the datastore
	AddMinerGroupToDeployment(context.Context, *MinerGroup) (*common.Void, error)
	// Adds a miner to a miner group
	AddMinerToMinerGroup(context.Context, *Miner) (*common.Void, error)
	// Adds a collection of Hashboard hashrate readings to a miner
	AddMinerHashboardReadings(context.Context, *HashboardHashrates) (*common.Void, error)
	// Adds a miner pool hashrate reading
	AddMinerPoolHashrateReading(context.Context, *MinerPoolHashrate) (*common.Void, error)
	// Adds a temp reading to a miner
	AddMinerTemperatureReading(context.Context, *MinerTemperature) (*common.Void, error)
	// Adds a voltage reading to the miner
	AddMinerVoltageReading(context.Context, *MinerVoltage) (*common.Void, error)
	// Adds a miner state change to the miner
	AddMinerStateChange(context.Context, *MinerState) (*common.Void, error)
}

func RegisterAntminerDataServer(s *grpc.Server, srv AntminerDataServer) {
	s.RegisterService(&_AntminerData_serviceDesc, srv)
}

func _AntminerData_AddMiner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMinerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMiner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMiner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMiner(ctx, req.(*AddMinerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetMinerGroupsByDeploymentID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.UniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetMinerGroupsByDeploymentID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetMinerGroupsByDeploymentID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetMinerGroupsByDeploymentID(ctx, req.(*stdprotos.UniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetManagedMinersByDeploymentID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.UniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetManagedMinersByDeploymentID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetManagedMinersByDeploymentID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetManagedMinersByDeploymentID(ctx, req.(*stdprotos.UniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetAllMinersByDeploymentID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.UniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetAllMinersByDeploymentID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetAllMinersByDeploymentID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetAllMinersByDeploymentID(ctx, req.(*stdprotos.UniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetAllMinersByMinerGroupID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.UniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetAllMinersByMinerGroupID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetAllMinersByMinerGroupID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetAllMinersByMinerGroupID(ctx, req.(*stdprotos.UniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetMinerHashrates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.TimeRangeWithUniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetMinerHashrates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetMinerHashrates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetMinerHashrates(ctx, req.(*stdprotos.TimeRangeWithUniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetMinerPoolHashrates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.TimeRangeWithUniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetMinerPoolHashrates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetMinerPoolHashrates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetMinerPoolHashrates(ctx, req.(*stdprotos.TimeRangeWithUniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetMinerTemperatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.TimeRangeWithUniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetMinerTemperatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetMinerTemperatures",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetMinerTemperatures(ctx, req.(*stdprotos.TimeRangeWithUniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetMinerVoltages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.TimeRangeWithUniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetMinerVoltages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetMinerVoltages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetMinerVoltages(ctx, req.(*stdprotos.TimeRangeWithUniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_GetMinerStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(stdprotos.TimeRangeWithUniqueID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).GetMinerStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/GetMinerStates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).GetMinerStates(ctx, req.(*stdprotos.TimeRangeWithUniqueID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_AddMinerGroupToDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMinerGroupToDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMinerGroupToDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMinerGroupToDeployment(ctx, req.(*MinerGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_AddMinerToMinerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Miner)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMinerToMinerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMinerToMinerGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMinerToMinerGroup(ctx, req.(*Miner))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_AddMinerHashboardReadings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashboardHashrates)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMinerHashboardReadings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMinerHashboardReadings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMinerHashboardReadings(ctx, req.(*HashboardHashrates))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_AddMinerPoolHashrateReading_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerPoolHashrate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMinerPoolHashrateReading(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMinerPoolHashrateReading",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMinerPoolHashrateReading(ctx, req.(*MinerPoolHashrate))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_AddMinerTemperatureReading_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerTemperature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMinerTemperatureReading(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMinerTemperatureReading",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMinerTemperatureReading(ctx, req.(*MinerTemperature))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_AddMinerVoltageReading_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerVoltage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMinerVoltageReading(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMinerVoltageReading",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMinerVoltageReading(ctx, req.(*MinerVoltage))
	}
	return interceptor(ctx, in, info, handler)
}

func _AntminerData_AddMinerStateChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MinerState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AntminerDataServer).AddMinerStateChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/antminerdataservice.AntminerData/AddMinerStateChange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AntminerDataServer).AddMinerStateChange(ctx, req.(*MinerState))
	}
	return interceptor(ctx, in, info, handler)
}

var _AntminerData_serviceDesc = grpc.ServiceDesc{
	ServiceName: "antminerdataservice.AntminerData",
	HandlerType: (*AntminerDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddMiner",
			Handler:    _AntminerData_AddMiner_Handler,
		},
		{
			MethodName: "GetMinerGroupsByDeploymentID",
			Handler:    _AntminerData_GetMinerGroupsByDeploymentID_Handler,
		},
		{
			MethodName: "GetManagedMinersByDeploymentID",
			Handler:    _AntminerData_GetManagedMinersByDeploymentID_Handler,
		},
		{
			MethodName: "GetAllMinersByDeploymentID",
			Handler:    _AntminerData_GetAllMinersByDeploymentID_Handler,
		},
		{
			MethodName: "GetAllMinersByMinerGroupID",
			Handler:    _AntminerData_GetAllMinersByMinerGroupID_Handler,
		},
		{
			MethodName: "GetMinerHashrates",
			Handler:    _AntminerData_GetMinerHashrates_Handler,
		},
		{
			MethodName: "GetMinerPoolHashrates",
			Handler:    _AntminerData_GetMinerPoolHashrates_Handler,
		},
		{
			MethodName: "GetMinerTemperatures",
			Handler:    _AntminerData_GetMinerTemperatures_Handler,
		},
		{
			MethodName: "GetMinerVoltages",
			Handler:    _AntminerData_GetMinerVoltages_Handler,
		},
		{
			MethodName: "GetMinerStates",
			Handler:    _AntminerData_GetMinerStates_Handler,
		},
		{
			MethodName: "AddMinerGroupToDeployment",
			Handler:    _AntminerData_AddMinerGroupToDeployment_Handler,
		},
		{
			MethodName: "AddMinerToMinerGroup",
			Handler:    _AntminerData_AddMinerToMinerGroup_Handler,
		},
		{
			MethodName: "AddMinerHashboardReadings",
			Handler:    _AntminerData_AddMinerHashboardReadings_Handler,
		},
		{
			MethodName: "AddMinerPoolHashrateReading",
			Handler:    _AntminerData_AddMinerPoolHashrateReading_Handler,
		},
		{
			MethodName: "AddMinerTemperatureReading",
			Handler:    _AntminerData_AddMinerTemperatureReading_Handler,
		},
		{
			MethodName: "AddMinerVoltageReading",
			Handler:    _AntminerData_AddMinerVoltageReading_Handler,
		},
		{
			MethodName: "AddMinerStateChange",
			Handler:    _AntminerData_AddMinerStateChange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.lakeparime.info/apis/antminerdataservice/antminerdataservice.proto",
}

func init() {
	proto.RegisterFile("golang.lakeparime.info/apis/antminerdataservice/antminerdataservice.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1258 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x8e, 0x3e, 0xac, 0xc8, 0x63, 0x39, 0x91, 0x27, 0xce, 0x0b, 0x59, 0x09, 0xf2, 0xaa, 0x84,
	0x9b, 0x1a, 0x46, 0xa1, 0xb4, 0xae, 0xd3, 0x36, 0x40, 0x0e, 0xd5, 0x87, 0x21, 0xb3, 0x89, 0x15,
	0x75, 0x29, 0x3b, 0x39, 0x15, 0xd9, 0x88, 0x1b, 0x99, 0xa8, 0xb4, 0xab, 0x70, 0xa9, 0xa4, 0xbe,
	0xfa, 0xda, 0x63, 0x2f, 0x45, 0x8f, 0x3d, 0xf6, 0x5f, 0xf4, 0x8f, 0xf4, 0x47, 0xf4, 0xd8, 0x53,
	0xc1, 0x25, 0x69, 0x91, 0x12, 0x2d, 0x32, 0x45, 0x0a, 0xf8, 0xa4, 0xdd, 0xf9, 0x78, 0x76, 0xe7,
	0xd9, 0x9d, 0x99, 0xa5, 0x40, 0x1f, 0x8a, 0x11, 0xe5, 0xc3, 0xfa, 0x88, 0xfe, 0xc0, 0x26, 0xd4,
	0xb6, 0xc6, 0xac, 0x6e, 0xf1, 0xd7, 0xe2, 0x01, 0x9d, 0x58, 0xf2, 0x01, 0xe5, 0xce, 0xd8, 0xe2,
	0xcc, 0x36, 0xa9, 0x43, 0x25, 0xb3, 0xdf, 0x5a, 0x03, 0x16, 0x27, 0xab, 0x4f, 0x6c, 0xe1, 0x08,
	0xbc, 0x15, 0xa3, 0xaa, 0xd6, 0x7d, 0xfc, 0x81, 0xe0, 0x36, 0x35, 0xdf, 0x09, 0x61, 0xd6, 0x39,
	0x73, 0x3c, 0xf8, 0x81, 0x18, 0x8f, 0x05, 0xf7, 0x7f, 0x3c, 0x90, 0xea, 0xc3, 0x65, 0xfb, 0x91,
	0x8e, 0xa9, 0xac, 0x42, 0x23, 0xcf, 0x4d, 0xdb, 0x85, 0x52, 0xcf, 0xe2, 0x43, 0xc2, 0xe4, 0x44,
	0x70, 0xc9, 0xb0, 0x0a, 0xc5, 0x60, 0x5c, 0xc9, 0xd4, 0x32, 0x3b, 0xab, 0xe4, 0x62, 0xae, 0xb5,
	0xe0, 0x66, 0xc3, 0x34, 0x8f, 0xdc, 0x9d, 0x12, 0xf6, 0x66, 0xca, 0xa4, 0x83, 0x9f, 0xc1, 0x8a,
	0x9a, 0x2b, 0xdb, 0xb5, 0xbd, 0x6a, 0x3d, 0x2e, 0x4a, 0xcf, 0xc3, 0x33, 0xd4, 0xfe, 0xce, 0x00,
	0xa8, 0x51, 0xc7, 0x16, 0xd3, 0x09, 0xd6, 0xa1, 0xd4, 0x66, 0x93, 0x91, 0x38, 0x1b, 0x33, 0xee,
	0xe8, 0x6d, 0x85, 0x93, 0x6f, 0xc2, 0xaf, 0xe7, 0x5b, 0x85, 0xa9, 0xc5, 0x9d, 0x2f, 0xf7, 0x49,
	0x44, 0x8f, 0x08, 0xf9, 0x2e, 0x1d, 0xb3, 0x4a, 0x56, 0xed, 0x4d, 0x8d, 0xb1, 0x06, 0x6b, 0x6d,
	0x26, 0x07, 0xb6, 0x35, 0x71, 0x2c, 0xc1, 0x2b, 0x39, 0xa5, 0x0a, 0x8b, 0x70, 0x1f, 0x6e, 0x7b,
	0x28, 0xcc, 0x3c, 0xe6, 0xd6, 0x8f, 0x7d, 0x6b, 0xcc, 0xa4, 0x43, 0xc7, 0x93, 0x4a, 0xde, 0x5d,
	0x8e, 0xc4, 0x2b, 0xb1, 0x0a, 0x59, 0xbd, 0x5d, 0x59, 0x59, 0xd8, 0x51, 0x56, 0x6f, 0xe3, 0x3e,
	0xdc, 0x6c, 0x37, 0xa3, 0x58, 0x85, 0x05, 0xc3, 0x79, 0x13, 0xed, 0xa7, 0xbc, 0xcf, 0x17, 0xbe,
	0x84, 0xd2, 0x8c, 0x05, 0x3f, 0xee, 0xb5, 0xbd, 0xff, 0x5f, 0xce, 0x9f, 0x32, 0x6c, 0xde, 0x99,
	0xa1, 0xff, 0x76, 0xbe, 0xb5, 0xae, 0x4c, 0x87, 0xae, 0xa6, 0x6e, 0x99, 0x24, 0x82, 0x88, 0x8f,
	0x61, 0x55, 0xcd, 0xfb, 0x67, 0x13, 0x8f, 0xae, 0x1b, 0x7b, 0xf7, 0x2e, 0x87, 0x77, 0xad, 0xc8,
	0xcc, 0x01, 0xef, 0xfa, 0xde, 0x8a, 0x6c, 0x8f, 0xd1, 0x99, 0x00, 0x77, 0xa1, 0xac, 0x26, 0x61,
	0xda, 0xf3, 0xca, 0x68, 0x41, 0x7e, 0x39, 0xf7, 0x2b, 0xc9, 0xdc, 0x17, 0xd2, 0x72, 0x7f, 0x3d,
	0x91, 0x7b, 0xac, 0x42, 0x4e, 0xef, 0xed, 0x57, 0x8a, 0xee, 0x36, 0x9b, 0xc5, 0xdf, 0xcf, 0xb7,
	0xf2, 0x8e, 0x3d, 0x65, 0xc4, 0x15, 0xe2, 0x3d, 0x80, 0xd6, 0xd4, 0xb6, 0x19, 0x77, 0x8e, 0xe8,
	0xa0, 0xb2, 0xaa, 0x22, 0x09, 0x49, 0x70, 0x1b, 0xd6, 0x0d, 0xe3, 0xb0, 0x67, 0x5b, 0x6f, 0xa9,
	0xc3, 0x9e, 0xb0, 0xb3, 0x0a, 0xd4, 0x32, 0x3b, 0x25, 0x12, 0x15, 0x62, 0x1d, 0xf0, 0x88, 0x72,
	0x3a, 0x64, 0x66, 0xf3, 0xac, 0x27, 0xde, 0x31, 0x9b, 0x0b, 0x93, 0x55, 0xd6, 0x6a, 0x99, 0x9d,
	0x22, 0x89, 0xd1, 0x68, 0x7f, 0x64, 0x61, 0xe3, 0x90, 0xca, 0xd3, 0x57, 0x82, 0xda, 0xa6, 0x3b,
	0xb0, 0xa9, 0xc3, 0x70, 0x1b, 0xae, 0x2b, 0x0e, 0x63, 0x93, 0x21, 0x50, 0xe1, 0xa7, 0x21, 0xd7,
	0x9e, 0x90, 0x96, 0x3a, 0x02, 0xf7, 0x94, 0xd7, 0xc9, 0xa2, 0x02, 0x09, 0x6c, 0x07, 0xf8, 0x0f,
	0x0d, 0x36, 0x68, 0xbc, 0x65, 0x36, 0x1d, 0x32, 0x9d, 0xbb, 0x42, 0x26, 0x7b, 0xcc, 0x36, 0xd8,
	0x40, 0x70, 0x53, 0x1d, 0x74, 0x86, 0xa4, 0xb2, 0xc5, 0x3d, 0xd8, 0x24, 0x8c, 0x9a, 0x16, 0x1f,
	0xc6, 0xa5, 0x54, 0xac, 0xee, 0xc3, 0x9f, 0xaa, 0xf6, 0x73, 0x16, 0x36, 0x14, 0x27, 0x3d, 0x21,
	0x46, 0xef, 0xc9, 0x61, 0x5a, 0x56, 0xb2, 0x1f, 0x80, 0x95, 0x5c, 0x22, 0x2b, 0xf9, 0xb4, 0xac,
	0xac, 0x24, 0xb3, 0xf2, 0x57, 0xc6, 0x4f, 0xd0, 0x3e, 0x1b, 0x4f, 0x98, 0x4d, 0x9d, 0xa9, 0x9d,
	0x96, 0x94, 0x3d, 0xd8, 0x0c, 0x39, 0xe9, 0xbc, 0xc5, 0x46, 0xd2, 0x9a, 0xca, 0x4a, 0xb6, 0x96,
	0xdb, 0xc9, 0x90, 0x58, 0xdd, 0x15, 0x09, 0xfa, 0x3c, 0xeb, 0x77, 0x16, 0xc3, 0x49, 0x7f, 0x07,
	0x0e, 0x61, 0xdd, 0x3d, 0x42, 0x8b, 0x0f, 0x5d, 0x2f, 0x15, 0xa7, 0x5b, 0x29, 0xb5, 0xd8, 0x4a,
	0x19, 0xb1, 0x24, 0x51, 0xc7, 0x2b, 0x42, 0xc2, 0x9f, 0x19, 0xbf, 0xb1, 0x9c, 0x88, 0x91, 0x43,
	0x87, 0x69, 0x69, 0xd0, 0xa2, 0x5e, 0xfe, 0x69, 0x47, 0x91, 0xae, 0x46, 0x80, 0x3d, 0x58, 0x9b,
	0xb5, 0x39, 0x89, 0x8d, 0xc8, 0xb4, 0x92, 0xa9, 0xe5, 0x52, 0xb4, 0x51, 0x12, 0xf6, 0xd1, 0x5e,
	0xc0, 0x7a, 0x38, 0x4e, 0x89, 0x9d, 0x39, 0x81, 0x8f, 0xfa, 0xd1, 0xe5, 0xa8, 0xbe, 0x25, 0x89,
	0xfa, 0x5d, 0xec, 0x55, 0x5d, 0xc8, 0xd9, 0x5e, 0xbd, 0x69, 0xf2, 0x5e, 0x95, 0x1d, 0x09, 0xfb,
	0x68, 0x23, 0xc0, 0x85, 0x8e, 0x21, 0xf1, 0x24, 0x4e, 0xea, 0xe3, 0xdf, 0xbf, 0xf4, 0x26, 0x47,
	0xcc, 0x49, 0x0c, 0x82, 0xbb, 0xda, 0x42, 0x6d, 0x55, 0xab, 0x2d, 0x4a, 0x97, 0xae, 0xb6, 0x60,
	0x4e, 0x62, 0x10, 0xb4, 0x53, 0xbf, 0x92, 0x87, 0x4a, 0x8c, 0x44, 0x23, 0x46, 0xe8, 0xaf, 0xf5,
	0xf1, 0x92, 0xd7, 0xcc, 0xcc, 0x9a, 0x2c, 0xfa, 0x6b, 0x8f, 0xa1, 0xa0, 0x84, 0x6e, 0xd2, 0xfa,
	0x23, 0x1f, 0x73, 0xd9, 0x03, 0xd6, 0xb7, 0xdc, 0x7d, 0x3d, 0x57, 0x32, 0xb0, 0x02, 0x9b, 0xc7,
	0xdd, 0x27, 0xdd, 0x67, 0xcf, 0xbb, 0x87, 0x0d, 0xe3, 0x50, 0xef, 0x76, 0x8c, 0x7e, 0xa3, 0x7f,
	0x6c, 0x94, 0xaf, 0x21, 0x40, 0xa1, 0xd1, 0xea, 0xeb, 0x27, 0x07, 0xe5, 0x0c, 0x16, 0x21, 0xaf,
	0xb7, 0x9f, 0x1e, 0x94, 0xb3, 0x58, 0x82, 0xa2, 0xd1, 0x6f, 0x90, 0xbe, 0xde, 0xed, 0x94, 0x73,
	0xb8, 0x0a, 0x2b, 0x07, 0x84, 0x3c, 0x23, 0xe5, 0xbc, 0xa7, 0x78, 0xd6, 0xeb, 0xb9, 0x8a, 0x95,
	0xdd, 0xaf, 0x43, 0x0f, 0x38, 0xdc, 0x80, 0xf5, 0x56, 0xe7, 0x48, 0xef, 0x1e, 0x90, 0xd6, 0x53,
	0xfd, 0xa0, 0xdb, 0x2f, 0x5f, 0xc3, 0x02, 0x64, 0x8d, 0x47, 0xe5, 0x0c, 0x5e, 0x87, 0x9c, 0xf1,
	0xf9, 0x57, 0xe5, 0xac, 0x37, 0x78, 0x54, 0xce, 0xed, 0xfd, 0xb2, 0x06, 0xa5, 0x86, 0x1f, 0x47,
	0x9b, 0x3a, 0x14, 0x9f, 0x42, 0x31, 0x78, 0xb9, 0xe3, 0x76, 0x6c, 0x88, 0x73, 0x0f, 0xfb, 0xea,
	0x12, 0x22, 0xf0, 0x18, 0xee, 0x76, 0x98, 0x13, 0x4a, 0xa1, 0xe6, 0x59, 0xe4, 0x8d, 0x7e, 0xab,
	0x3e, 0xfb, 0xca, 0x38, 0xe6, 0xd6, 0x9b, 0x29, 0xd3, 0xdb, 0xd5, 0x5a, 0x42, 0x4e, 0x4a, 0x24,
	0x70, 0xcf, 0x85, 0xf5, 0xde, 0x49, 0x1e, 0xd7, 0x69, 0x80, 0xef, 0x5c, 0x0e, 0x2c, 0xb1, 0x0b,
	0xd5, 0x0e, 0x73, 0x1a, 0xa3, 0xd1, 0x7f, 0x85, 0x17, 0x79, 0x72, 0xbf, 0x3f, 0xde, 0xf7, 0xb0,
	0x11, 0x50, 0x39, 0x4b, 0xb0, 0x5a, 0x08, 0xc6, 0x2d, 0x7c, 0x84, 0xf2, 0x21, 0x7b, 0x6e, 0x39,
	0xa7, 0x17, 0x98, 0x9f, 0xa4, 0x4b, 0x6a, 0x89, 0xaf, 0xe0, 0x76, 0x80, 0x1f, 0x4d, 0xe2, 0x7f,
	0xbb, 0x46, 0x0c, 0xd4, 0x4b, 0xd8, 0x0c, 0xd6, 0x88, 0xa4, 0x6e, 0xf2, 0x12, 0xf7, 0x53, 0x65,
	0xb0, 0xc4, 0x17, 0x50, 0x0e, 0x56, 0xb8, 0x28, 0xd2, 0xc9, 0xe8, 0x5a, 0x62, 0xbd, 0x96, 0xd8,
	0x87, 0x1b, 0x01, 0xb2, 0x5f, 0xa4, 0x93, 0x71, 0x6b, 0x09, 0x15, 0x5b, 0xe2, 0xb7, 0xb0, 0x15,
	0xe4, 0x93, 0xba, 0x1a, 0x7d, 0x31, 0xbb, 0x76, 0x98, 0xd4, 0x9c, 0xaa, 0xa5, 0xba, 0xff, 0x61,
	0x7f, 0x22, 0x2c, 0x13, 0xbf, 0x81, 0xcd, 0x00, 0xab, 0x2f, 0x42, 0x1f, 0xce, 0x4b, 0x12, 0x74,
	0x0e, 0x81, 0xcc, 0x76, 0x73, 0x71, 0x43, 0xfc, 0x66, 0x2d, 0x31, 0xed, 0x4d, 0x9a, 0xc3, 0x34,
	0xe0, 0x4e, 0x80, 0x19, 0xa9, 0xeb, 0x1e, 0x2c, 0xa6, 0x6c, 0x03, 0x73, 0xa0, 0xdf, 0x41, 0xf5,
	0x22, 0xd4, 0x50, 0x01, 0xf7, 0x31, 0xd3, 0x95, 0xfb, 0x39, 0x48, 0x1d, 0xfe, 0x17, 0x40, 0x06,
	0x3d, 0xda, 0x87, 0x4b, 0xee, 0xe6, 0x73, 0x50, 0x6d, 0xb8, 0x15, 0x40, 0xa9, 0x63, 0x6e, 0x9d,
	0xba, 0x37, 0x03, 0x93, 0xfa, 0x77, 0x14, 0xa5, 0xb9, 0x0b, 0x3b, 0x16, 0x7f, 0x2d, 0xc2, 0x7f,
	0xd3, 0xd0, 0x89, 0x25, 0xe3, 0x40, 0x5e, 0x15, 0xd4, 0x35, 0xfc, 0xe2, 0x9f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x1b, 0xa2, 0x10, 0x57, 0x6b, 0x12, 0x00, 0x00,
}
